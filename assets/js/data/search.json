[ { "title": "Typescript Utility Types 훑어보기", "url": "/posts/ts-utility-type/", "categories": "Dev, Frontend", "tags": "typescript", "date": "2023-12-03 00:00:00 +0900", "snippet": "Utility Types?Typescript에서 제공하는 타입이며 일반 타입을 편리(정말?)하게 활용 할 수 있게 해준다.강타입 언어를 넘어 최강타입 언어정도가 되는게 목적이 아닐까?굳이 언어 레벨에서 별도의 타입으로 제공할만한 내용들일까..? 라는 의문이 들지만 typescript 기반 라이브러리 내부 구현 파악에 필요하므로 한번 살펴보자.정리하다보니 왠지 모르게 자바스크립트에 대한 호감도가 상승했다.AwaitedT 가 Promise인 경우 Promise를 unwrap 해준다.type A = string | Promise&amp;lt;number&amp;gt;A = string | numbertype ShitTS = Promise&amp;lt;Promise&amp;lt;Promise&amp;lt;string&amp;gt;&amp;gt;&amp;gt;type B = Awaited&amp;lt;ShitTS&amp;gt;B = stringPartialT의 프로퍼티의 부분 집합을 사용 할 수 있다.type User { name: string; age: number;}function updateUser(user: User, partial: Partial&amp;lt;User&amp;gt;) { return { ...user, ...partial }}RequiredT의 모든 프로퍼티가 필수로 요구된다.type User { name?: string; age?: number;}const user: User = { name: &quot;name&quot; } // okconst requiredUser: Required&amp;lt;User&amp;gt; = { name: &quot;name&quot; } // error!ReadonlyT의 프로퍼티들은 불변이다.type User { name: string}const user: Readonly&amp;lt;User&amp;gt; = { name: &quot;name&quot; }user.name = &quot;new name&quot; // error!Record&amp;lt;K, T&amp;gt;property = K, value = Tinterface CatInfo { age: number; breed: string;}type CatName = &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;const cats: Record&amp;lt;CatName, CatInfo&amp;gt; = { miffy: { age: 10, breed: &quot;Persian&quot; }, boris: { age: 5, breed: &quot;Maine Coon&quot; }, mordred: { age: 16, breed: &quot;British Shorthair&quot; },};Pick&amp;lt;T, K&amp;gt;원하는 property를 선택 할 수 있다.여러 sub type이 필요한 경우 사용.interface Main { a: string, b: string, c: string}type SubA = Pick&amp;lt;Main, &quot;a&quot;&amp;gt;type SubAB = Pick&amp;lt;Main, &quot;a&quot; | &quot;b&quot;&amp;gt;Omit&amp;lt;T, K&amp;gt;원하는 property들을 제거 마찬가지로 서브타입 정의에 활용interface Main { a: string, b: string, c: string}type SubWithoutA = Omit&amp;lt;Main, &quot;a&quot;&amp;gt;type SubWithoutAB = Omit&amp;lt;Main, &quot;a&quot; | &quot;b&quot;&amp;gt;Exclude&amp;lt;UnionType, Members&amp;gt;UnionType에서 특정 타입을 제거한다.type Shape = | { kind: &quot;circle&quot;; radius: number } | { kind: &quot;square&quot;; x: number } | { kind: &quot;triangle&quot;; x: number; y: number };type T3 = Exclude&amp;lt;Shape, { kind: &quot;circle&quot; }&amp;gt;//T3 is square or triangleExtract&amp;lt;UnionType, Type&amp;gt;UnionType에서 원하는 type을 추출한다.type Shape = | { kind: &quot;circle&quot;; radius: number } | { kind: &quot;square&quot;; x: number } | { kind: &quot;triangle&quot;; x: number; y: number };type T2 = Extract&amp;lt;Shape, { kind: &quot;circle&quot; }&amp;gt;//T2 is circle이 외에도 NonNullable, Parameters, ConstructorParameters, ReturnType, InstanceType, ThisParameterType, OmitThisParameter, ThisType 등 이 더 있다. 그만 알아보자..당연한 이야기이지만, 강타입은 결국 static type check를 지원한다는 의미가 가장 크다. 이를 통해 동적 타입에서는 런타임에서만 식별되어지는 여러 휴먼 에러들을 사전에 방지할 수 있다.즉, 우리가 짜는 코드가 더 “안전” 해지는 것이다. 공짜 점심은 없다는 말처럼 강타입 언어에서는 그에 따른 오버헤드가 반드시 따른다.내가 바라보는 타입스크립트가 얘기하는 안전의 범위는 끝이 없어 보인다. 즉, 끝도 없이 안전해 질 수 있고 그에 비례하여 오버헤드도 함께 증가 할 수 있어 보인다. 좋은걸까? 나는 무조건 TS 기반의 프로젝트를 만들긴하겠지만 Utility Type의 3-4개 정도를 제외하면 실제 사용할 일은 없을듯하다. 효용성이 없어 보인다.JS는 너무 약하고, TS는 너무 강해지려한다. 오늘도 평화로운 웹 세상이다.ReferenceUtility Types" }, { "title": "Redux: createAsyncThunk?", "url": "/posts/redux-create-thunk/", "categories": "Dev, Frontend", "tags": "react, redux", "date": "2023-11-23 00:00:00 +0900", "snippet": "Redux?JS 진영의 대표적인 상태 관리 라이브러리 중 하나, Flux 패턴을 활용한 또 하나의 variant 정도로 보여지며 Flux에서 이야기하는 component들을 잘 추상화하여 제공해준다. 완성도가 꽤나 높은 라이브러리.createAsyncThunkFlux pattern에서 State를 변경하는 코드로 나타내면 아래와 같다dispatch(Action): State 흔히 reducer라고 표현하는 그것이다.여기서, 네트워크 통신 또는 파일 IO 등이 필요한 비동기 처리를 하는과정을 SideEffect 라고 얘기하며 일반적으로 관련 구현을 살펴보면 아래와 같다.const fetchData = () =&amp;gt; { dispatch(setLoading(true)) try { const data = fetchData() dispatch(loaded(data)) } catch(e) { dispatch(failure(e)) } dispatch(setLoading(false))}fetchData의 parameter관련 로직을 구현하거나 response 결과에 따라 에러 핸들링을 구현한다거나하면 코드의 복잡도는 높아지고 불필요한 중복이 많이 발생하는 문제가 있다.관련해서 실제 프로젝트 작업시에는 관련 공통 구현을 묶어 delegate를 구현하는식으로 작업을 많이하는데 Redux에서는 관련 구현이 포함되어있다.createAsyncThunk는 이런 비동기 요청과 관련된 높은 추상화를 지원해주며 reducer 또는 view logic을 작성할 때 관련 의존성을 줄여준다.적용해보자위 예시를 그대로 적용해보자면const fetchData = createAsyncThunk( URL, async () =&amp;gt; { const resp = await apiGetData() return resp.data }}...const mySlice = createSlice({ name: &#39;users&#39;, initialState, reducers: { ... }, extraReducers: (builder) =&amp;gt; { builder.addCase(fetchData.fulfilled, (state, action) =&amp;gt; { state.data = action.payload state.loading = false }), builder.addCase(fetchData.pending, (state, action) =&amp;gt; { state.loading = true }), builder.addCase(fetchData.rejceted, (state, action) =&amp;gt; { state.error = {...} state.loading = false }), },})위 처럼 Slice를 구현하고 thunk를 dispatch하여 사용하면된다. Good!dispatch(fetchData)결론최근 주로 Next.js를 활용하여 작업을 많이하는데 웹 진영은 standard가 너무 많다. 타 진영을 보면 기본적으로 활용되어지는 core는 비슷하되 아키텍처 수준에서의 variant가 많은데 웹은 core한 부분부터 선택지가 베라 x 10정도 되는듯; 너무 많다. Next.js + jotai 기반 프론트엔드 작업을 쭉하다가 react + redux 조합의 프로젝트를 진행하려니 난감하다. 어려움을 떠나 다른점이 너무많다. 같은 플랫폼 작업을 하는게 맞나 싶을정도.. 아무튼 하루빨리 진짜 standard가 정해지길..Referencehttps://redux-toolkit.js.org/api/createAsyncThunk" }, { "title": "제주도 클린하우스 위치찾기 서비스", "url": "/posts/jeju/", "categories": "Life", "tags": "nextjs", "date": "2023-08-12 00:00:00 +0900", "snippet": "클린하우스?제주도에서 쓰레기와 재활용품을 배출하는 곳.제주도에 숙소를 구해두고 자주 내려가고 있는데 최근 쓰레기 배출을 하다가 개고생해서 만들었다. (관련 앱이 있는데 위치정보가 잘못되어있더라..)기능공공데이터 포털에서 최신데이터를 수집하여 지도에 표시.제주도 클린하우스찾기" }, { "title": "Spring, opencsv 활용하여 csv 내보내기", "url": "/posts/spring-csv/", "categories": "Dev, Spring", "tags": "spring, opencsv", "date": "2023-07-07 00:00:00 +0900", "snippet": "OpenCSVjvm을 지원하는 csv 라이브러리 중 가장 지원하는 커스텀 기능과 사용성이 좋아 csv를 다룰 일이 있으면 사용 중.Comparator간단한 Comparator이며 reflection을 이용하여 클래스의 프로퍼티 순서대로 칼럼이 생성되도록 구현class MyComparator&amp;lt;T&amp;gt;(private val clazz: Class&amp;lt;T&amp;gt;) : Comparator&amp;lt;String&amp;gt; { private val memberOrder: List&amp;lt;String&amp;gt; by lazy { FieldUtils.getAllFields(clazz) .map { it.getDeclaredAnnotation(CsvBindByName::class.java) } .map { it?.column ?: &quot;&quot; } .map { it.uppercase(Locale.US) } } override fun compare(field1: String?, field2: String?): Int { return memberOrder.indexOf(field1) - memberOrder.indexOf(field2) } companion object { inline fun &amp;lt;reified T&amp;gt; of() = StatisticsComparator(T::class.java) }}Extensioncsv 추출 시 중복코드가 많이 발생하여 HttpServletResponse의 extension으로 작업inline fun &amp;lt;reified T&amp;gt; HttpServletResponse.csv(filename: String, items: List&amp;lt;T&amp;gt;) { val contentDisposition = ContentDisposition.builder(&quot;attachment&quot;) .filename(filename, StandardCharsets.UTF_8) .build().toString() val mappingStrategy = HeaderColumnNameMappingStrategy&amp;lt;T&amp;gt;().apply { setColumnOrderOnWrite(StatisticsComparator.of&amp;lt;T&amp;gt;()) type = T::class.java setErrorLocale(Locale.US) } contentType = &quot;text/csv; charset=UTF-8&quot; characterEncoding = &quot;UTF-8&quot; addHeader(HttpHeaders.CONTENT_DISPOSITION, contentDisposition) OutputStreamWriter(outputStream).use { val beanToCsv = StatefulBeanToCsvBuilder&amp;lt;T&amp;gt;(it) .withMappingStrategy(mappingStrategy).build() beanToCsv.write(items) }}Use//somewhere in Controller :)@GetMapping(&quot;csv&quot;)fun getCsv( parameters: ParametersForCSV response: HttpServletResponse) { response.csv(&quot;MY_CSV.csv&quot;, service.getAll(parameters))}" }, { "title": "Nextjs, Nodejs, csv 파일 업로드 및 파싱", "url": "/posts/csv-parse/", "categories": "Dev, Frontend", "tags": "nextjs, csv", "date": "2023-07-04 00:00:00 +0900", "snippet": "지난 블로그에서 드래그 &amp;amp; 드롭 파일 업로드를 구현을 정리했는데 이번엔 csv 파일 업로드와 파싱관련하여 레퍼런스찾기가 힘들다.. 검색해보면 죄다 csv-parser를 사용한 예시인데 csv-parse는 fs의 ReadStream만 활용할 수 있기때문에 HTTP POST body를 파싱하기엔 적절하지 않다.일부 예시는 이런경우 body(Blob)을 로컬에 파일로 저장 한 뒤 ReadStream을 만들어서 사용하면 된다고하는데 왜그래…파일 업로드So simple, 이때까지만 해도 금방 끝날 줄만 알았던 작업이…fetch(&#39;/api/product&#39;, { method: &#39;POST&#39;, body: file}).then((response) =&amp;gt; { //handle response});Backend서론이 길었으니 바로 결과로..찾아보니 string을 지원하는csv-parse 라이브러리가있어서 사용.csv-parser와는 다른 라이브러리이다.import { parse } from &#39;csv-parse&#39;;...export async function POST(request: Request) { const records: any[] = await request .blob() .then((blob) =&amp;gt; blob.text()) .then((text) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { parse(text, (err, output) =&amp;gt; { if (err) reject(err); else resolve(output); }); }); }); //handle records //response result}" }, { "title": "React, tailwind: 드래그 &amp; 드롭 파일 업로드", "url": "/posts/drag-drop/", "categories": "Dev, Frontend", "tags": "nextjs, tailwind", "date": "2023-07-03 00:00:00 +0900", "snippet": "최근 오랜만에 프론트엔드 NextJS 작업 할 일이 많아졌는데 여전히 제대로된 레퍼런스 찾기가 쉽지않다.드래그 &amp;amp; 드롭 파일 업로드작업중인 대시보드에 그저 드래그&amp;amp;드롭 파일업로드를 넣고 싶었을뿐인데..인터넷 서칭해서 대충 복붙하니 원하는데로 동작하지않고 불필요한 구현이 많아보인다..그냥 새롭게 만들어보자.원하는것Just 드래그 &amp;amp; 드롭 또는 클릭해서 파일업로드!!결과물flowbite에서 적당한 컴포넌트를 가지고와서 작업.const DragAndDropFile = () =&amp;gt; { const onDrag: DragEventHandler&amp;lt;HTMLElement&amp;gt; = (e) =&amp;gt; { e.preventDefault(); e.stopPropagation(); }; const onDrop: DragEventHandler&amp;lt;HTMLElement&amp;gt; = (e) =&amp;gt; { e.preventDefault(); e.stopPropagation(); if (e.dataTransfer.files &amp;amp;&amp;amp; e.dataTransfer.files[0]) { handleFiles(e.dataTransfer.files); } }; const onChange = (event: any) =&amp;gt; { handleFiles(event.target.files); }; const handleFiles = (files: FileList) =&amp;gt; { const file = files[0]; if (!file) return; /** * TODO 확장자 체크 * 파일업로드 등 구현 */ }; return ( &amp;lt;div className=&quot;flex items-center justify-center w-full&quot; onDragEnter={onDrag} onDragLeave={onDrag} onDragOver={onDrag} onDrop={onDrop} &amp;gt; &amp;lt;label htmlFor=&quot;dropzone-file&quot; className=&quot;flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600&quot; &amp;gt; &amp;lt;div className=&quot;flex flex-col items-center justify-center pt-5 pb-6&quot;&amp;gt; &amp;lt;svg className=&quot;w-8 h-8 mb-4 text-gray-500 dark:text-gray-400&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 20 16&quot; &amp;gt; &amp;lt;path stroke=&quot;currentColor&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2&quot; /&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;p className=&quot;mb-2 text-sm text-gray-500 dark:text-gray-400&quot;&amp;gt; &amp;lt;span className=&quot;font-semibold&quot;&amp;gt;Click to upload&amp;lt;/span&amp;gt; or drag and drop &amp;lt;/p&amp;gt; &amp;lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&amp;gt; Upload CSV file &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;input id=&quot;dropzone-file&quot; type=&quot;file&quot; className=&quot;hidden&quot; accept=&quot;.csv&quot; onChange={onChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/div&amp;gt; );};" }, { "title": "AWS Lambda, 기본 설정 및 jar 배포하기", "url": "/posts/lambda-jar/", "categories": "Dev, DevOps", "tags": "aws, lambda", "date": "2023-06-28 00:00:00 +0900", "snippet": "for 비용 절감특정 시간마다 API scraping을 진행하는 작업은 구현했다.이걸 따로 container에서 돌리자니 비용이 아까워서 aws lambda로 배포하여 trigger를 등록하는 형태로 작업했다. duration 10~20 초, 6시간 간격으로 호출jar 관련된 셋업이나 gradle kotlin dsl 기준으로 작성된 내용은 없어서 따로 정리.Build.gradle.ktsdependencies { ... implementation(&quot;com.amazonaws:aws-lambda-java-core:1.2.2&quot;) implementation(&quot;com.amazonaws:aws-lambda-java-events:3.11.1&quot;) runtimeOnly(&quot;com.amazonaws:aws-lambda-java-log4j2:1.5.1&quot;)}// packageJar task 등록tasks.register&amp;lt;Zip&amp;gt;(&quot;packageJar&quot;) { into(&quot;lib&quot;) { from(tasks.jar) from(configurations.runtimeClasspath) }}// dependsOn, task 의존 관계를 추가, 즉 build task 호출 시 packageJar task 진행tasks.named(&quot;build&quot;) { dependsOn(&quot;packageJar&quot;)}Handlerclass Handler : RequestHandler&amp;lt;Map&amp;lt;String,String&amp;gt;, String&amp;gt; { override fun handleRequest(input: Map&amp;lt;String,String&amp;gt;?, context: Context?): String? { val parameters = input.asParameters() return Scraper.scrap(parameters) }}Lambda function 호출 시 사용할 input(parameter) 와 output을 명시하고 작업Build jar./gradlew buildbuild/distributions/ 경로에 jar파일 생성아래 배포 및 트리거 추가작업은 AWS console에서도 쉽게 배포가능하다, 편한 방식으로 진행하면된다.배포aws cli 관련 설정 및 lambda, events 관련 권한을 가진 iam 준비가 필요하다.createaws lambda create-function --function-name api-scrap \\--runtime java11 --handler com.example.Handler \\--role [MY_ROLE_ARN] \\--zip-file fileb://./build/distributions/scraper.zipupdateaws lambda update-function-code --function-name api-scrap \\--zip-file fileb://./build/distributions/scraper.zipTriggerCreate rule원하는것: 6시간 간격으로 호출aws events put-rule \\--name every-6hours \\--schedule-expression &#39;rate(6 hours)&#39;결과에서 EVENT_ARN 값 획득함수 호출 권한 Grantaws lambda add-permission \\--function-name api-scrap \\--statement-id scrap-event \\--action &#39;lambda:InvokeFunction&#39; \\--principal events.amazonaws.com \\--source-arn [EVENT_ARN]Event에 타겟 추가targets.json[ { &quot;Id&quot;: &quot;1&quot;, &quot;Arn&quot;: [LAMBDA_FUNCTION_ARN] }]aws events put-targets --rule every-6hours --targets file://targets.json끗!Referencehttps://docs.aws.amazon.com/lambda/latest/dg/java-package.html" }, { "title": "Solidity: Proxy 정리", "url": "/posts/solidity-proxy/", "categories": "Dev, Blockchain", "tags": "blockchain, solidity", "date": "2023-03-14 00:00:00 +0900", "snippet": "왜 필요한가? 스마트 컨트랙트를 통해 트랙잭션이 생성되며 이에 대한 검증과정을 거쳐 네트워크상에 추가된다. 이때 추가되는 기록과 배포된 스마트 컨트랙트 불변이다.여기서, 만약 배포된 스마트 컨트랙트에 취약점 또는 버그가 발견되었거나 기능을 추가하고 싶다면 어떻게 해야될까?스마트 컨트랙트는 불변이므로 직접 배포된 컨트랙트를 수정하거나 하는 일은 불가능하다.이 때 사용 할 수 있는것이 Proxy pattern이며 UUPS, Transparent, Beacon 등 여러 구현 방식이 있다.본 글에서는 Solidity에서 proxy pattern 이해하기위해 필요한 내용들과 구현 방식들 에 대한 설명 및 장단점에 대해 정리한다.Delegate callContract에서 다른 주소의 Contract code를 동적으로 실행Caller Contract Storage의 주소와 상태 값은 의 내용을 유지하되 코드만 호출하는 방식How to work?https://eips.ethereum.org/EIPS/eip-1822Proxy contract에서 delegatecall 을 통해 Logic contract의 code만 호출하는 방법.delegate call을 통하므로 Storage 영역은 Proxy contract(caller)의 값을 그대로 사용한다.Transparent Proxy 현재 해당 Standard는 Deprecated 상태이며 이를 개선한 ERC-2535: Diamonds, Multi-Facet Proxy를 사용할 것은 권장한다.proxy selector clashing 문제를 해결하기위 제안된 proxy 구현 Contract의 모든 함수는 4byte의 함수 식별자로 분류된다. 단일 Contract 내부에서는 함수 식별자가 충돌 할 문제는 없지만 Proxy Contract와 Logic Contract 간에는 충돌할 수 있는 위험이있다.동작 방식 msg.sender에 따라 위임 여부를 결정하는 방식으로 구현한다. 만약 sender가 Admin이면 위임 delegateCall을 비활성화 한다 upgradeTo 함수만 호출가능하다. 그 외의 경우 모든 호출을 delegateCall하다. Proxy Contract 자체의 함수는 호출하지 않는다. UUPS Proxy patternUniversal Upgradeable Proxy Standard, Proxy contract의 모든 호출은 delegateCall을 통해 Logic Contract로 위임된다. Transparent proxy의 Upgrade의 책임이 Proxy Contract에 있는 반면 UUPS Proxy의 경우 Logic Contract에 있다Beacon Proxy pattern기존 Proxy에서 Logic Contract를 사용하는 Proxy Contract가 N개인 경우 Logic Contract가 새롭게 배포되면 새로운 주소를 N번 업데이트 해야되는 문제가 있었다. 이를 해결하기위해 Beacon Contract를 중간에 두고 Proxy Contract에서 Beacon Contract를 통해 Logic Contract의 주소를 획득한 뒤 호출하는 Proxy pattern.결론Proxy Contract들의 기본적인 구현 종류에 대해 정리해봤으며 해당 Proxy들을 개선한 버전의 Proxy (Minimal, Diamond 등)이 존재한다.어떤 Proxy를 사용하더라도 결국은 추가적인 트랜잭션 비용이 발생 할 수 밖에 없다.각 프록시 별 Motivation과 Feature를 잘 이해하고 구현하는 Contract의 기능에 적합한 Proxy를 선택하는 것이 중요하고 만약 필요하지않다면 Proxy 패턴을 적용하지 않는것이 좋다.참조https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#https://eips.ethereum.org/EIPS/eip-1167https://eips.ethereum.org/EIPS/eip-1538https://eips.ethereum.org/EIPS/eip-1967https://eips.ethereum.org/EIPS/eip-2535" }, { "title": "Solidity: storage, memory, calldata", "url": "/posts/solidity-data-loc/", "categories": "Dev, Blockchain", "tags": "blockchain, solidity", "date": "2023-03-01 00:00:00 +0900", "snippet": "Storage블록체인 네트워크에 영구적으로 저장되는 데이터일반적으로 스마트 컨트랙트의 모든 상태 값(함수 스코프 외부에 있는 변수)들은 storage 영역에 저장된다.struct 혹은 dynamic array와 같은 동적 변수를 제외하면 32 byte 단위로 패킹된다.동적 타입(s의 경우 32 byte 사이즈로 패킹되며 실제 값들은 Keccak-256 계산된 별도의 슬롯에 저장된다.상수값의 경우 storage 공간에 저장되는 것이 아닌 스마트 컨트랙트 바이트코드에 직접 주입된다.Memory함수 스코프 내부에서 사용되어지며 스코프가 종료되면 휘발되는 임시 데이터storage와 비교하여 비용이 저렴하므로 구현하는 컨트랙트에 적합하게 작성해야된다.Space storage vs memoryuint4[4] arr;위 처럼 unit4 타입의 array가 있는경우 storage 영역에서는 1 slot (32bytes)만 차지하는반면 memory 공간에서는 128 bytes (32bytes each elements) 를 차지한다.Calldatamemory와 라이프사이클은 동일하지만 읽기 전용스마트 컨트랙트의 함수가 호출될때 읽기 전용으로 사용 할 파라미터에 사용하면 된다. 만약 memory를 사용하는 경우 파라미터를 memory 공간에 복사하는 과정이 필요하므로 추가 가스비가 발생한다다만, 읽기 전용이므로 수정이나 return 에 활용하는것은 불가능하므로 필요에 따라 적절한 키워드를 사용하면 된다.참조https://docs.soliditylang.org/en/v0.8.13/internals/layout_in_storage.htmlhttps://docs.soliditylang.org/en/v0.8.13/internals/layout_in_memory.htmlhttps://docs.soliditylang.org/en/v0.8.13/internals/layout_in_calldata.html" }, { "title": "Blockchain이란?", "url": "/posts/blockchain-intro/", "categories": "Dev, Blockchain", "tags": "blockchain", "date": "2023-02-14 00:00:00 +0900", "snippet": "Blockchain? 블록체인은 네트워크 상에서 트랜잭션의 기록과 자산 추적에 활용가능한 공유된 불변한 원장(shared immutable ledger) 을 뜻한다.여기서, 자산은 유형자산 (tangible, 부동산, 차량, 현금 등) 및 무형자산 (intangible, 저작권, 특허 등) 모두가 될 수 있다.따라서, 가치를 나타내는 어떤 것이라도 블록체인 네트워크에서 거래하고 그 내역을 블록체인 (불변 원장)으로 관리함으로써 사용자의 위험과 서비스 제공자의 비용을 줄일 수 있다.그래서?필자는 블록체인의 정의를 살펴보면 “이미 우리가 만드는 서비스들 또한 자산의 변동이나 거래 내역은 불변이며 추적도 가능한데 왜 블록체인이라는 새로운 기술이 뜨거울까?” 라는 의문이 들었으며 본 글에서 관련 정보를 정리해보고자 한다.블록체인의 구성요소분산 원장 기술(Distributed ledger technology) 모든 네트워크 사용자는 분산 원장과 기록된 트랜잭션 정보에 접근할 수 있다. 공유 원장을 기반으로 네트워크 상의 모든 거래는 한 번만 기록된다.불변 기록 (Immutable record) 기록이 완료된 공유 원장의 정보는 어떤 사용자도 조작할 수 없다. 원장의 트랜잭션에 결함이 있는 경우, 새로운 트랜잭션을 추가해야 하며 두 트랜잭션 모두 기록된다스마트 컨트랙트 (smart contract) 트랜잭션의 속도 향상을 위해 정의된 규칙이다. 이 규칙은 블록체인 네트워크상에 저장되며 자동으로 실행된다.장점은?높은 신뢰성스마트 컨트랙트를 토대로 모든 트랙잭션은 허가된 사용자로부터 정의된 데이터의 형태로만 적재된다. 또한 데이터 블록의 설정에따라 허가된 사용자만이 저장된 데이터에 접근 가능하다.보안모든 트랜잭션은 합의과정을 거쳐 저장되며 검증이 완료된 모든 트랙잭션은 영구적으로 기록되며 불변하다.효율성기존의 네트워크상에서 트랙잭션 관리에 불필요한 중복 저장이 많이 필요했던 반면 블록체인은 모든 트랙잭션을 단 일회만 저장하므로 효율적이다.또한 불필요한 트랜잭션 관련 검증절차도 불필요하다.결론계속 알아가겠지만 글쎄… 흥미가 생기는 기술이긴하나 기존의 엔터프라이즈 서비스가 그렇게 신뢰성이 부족했나? 보안도? 블록체인이 정말 효율적일까?라는 의문이 생긴다. 좀 더 알아보도록 하자.참조https://www.investopedia.com/terms/b/blockchain.asphttps://www.ibm.com/topics/what-is-blockchain" }, { "title": "Spring ELK Marker를 활용하여 특정 로그만 Logstash appender로 수집하기", "url": "/posts/spring-appender-marker/", "categories": "Dev, DevOps", "tags": "logstash, ELK", "date": "2023-02-07 00:00:00 +0900", "snippet": "Markerslf4j에 포함된 interface이며 다양한 용도로 활용가능하다.대표적으로 turboFilter의 MarkerFilter가 있으며 전체 로그를 대상으로 marker filtering을 적용하고싶으면 이를 활용하면 된다.본글에서는 전체 로그 대상이 아닌 단일 appender를 대상으로 marker filtering을 적용하는 방법을 정리한다Single Appender Filter?&amp;lt;appender name=&quot;log-stash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&amp;gt; &amp;lt;destination&amp;gt;~~~&amp;lt;/destination&amp;gt; &amp;lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&amp;gt; &amp;lt;customFields&amp;gt;{&quot;service&quot;:&quot;my-service&quot;}&amp;lt;/customFields&amp;gt; &amp;lt;/encoder&amp;gt;&amp;lt;/appender&amp;gt;logback의 configuration의 일부분이며 상용 서비스의 경우 다양한 appender가 포함되어있을것이다.만약 특정 appender log-stash 에 filter를 적용하고싶을때 turboFilter를 활용 할 수 없으며 regularFilter인 CustomFilter를 구현하여 따로 적용해야된다.Regular Marker Filterobject Markers { val Access: Marker by lazy { MarkerFactory.getMarker(&quot;ACCESS&quot;) }}class AccessMarkerFilter : Filter&amp;lt;ILoggingEvent&amp;gt;() { override fun decide(event: ILoggingEvent?): FilterReply { return if (event?.marker == Markers.Access) FilterReply.ACCEPT else FilterReply.DENY }}위 처럼 간단하게 구현가능하다. FilterReply.ACCEPT FilterReply.NEUTRAL 하위 필터가 존재하면 해당 필터의 decide 적용 없으면 ACCEPT FilterReply.DENY적용&amp;lt;appender name=&quot;log-stash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&amp;gt; ... &amp;lt;filter class=&quot;com.example.filter.AccessMarkerFilter&quot;/&amp;gt; ...&amp;lt;/appender&amp;gt;logger.trace(Markers.Access, ~~~)위 처럼 access logging을 구현한 곳에서 Marker값을 지정하고 Filter를 적용해두면 logstash에 원하는 accesslog만 수집되는 것을 확인 할 수 있다." }, { "title": "Spring access log Logstash 수집하기", "url": "/posts/spring-logstash-access/", "categories": "Dev, DevOps", "tags": "logstash, ELK", "date": "2023-02-06 00:00:00 +0900", "snippet": "spirng boot + ELK stack 구현 시 http access logging을 빠르게 구현하고 싶을때 적용 할 수 있는 방법 정리의존성implementation(&quot;org.slf4j:slf4j-api&quot;)implementation(&quot;net.logstash.logback:logstash-logback-encoder&quot;)implementation(&quot;ch.qos.logback:logback-access&quot;)implementation(&quot;ch.qos.logback:logback-classic&quot;)LogStashAppender, Encoder를 사용하기때문에 위 의존성을 프로젝트에 추가하여야한다. 현재 프로젝트의 의존성을 확인하여 적절한 버전 명시 필요dependencyManagement를 사용하여 의존성 중복문제를 발생하지 않도록 작업하는것을 추천한다.logback-access.xml 작성&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;configuration&amp;gt; &amp;lt;appender name=&quot;access&quot; class=&quot;net.logstash.logback.appender.LogstashAccessTcpSocketAppender&quot;&amp;gt; &amp;lt;destination&amp;gt;{LOGSTASH ADDRESS}&amp;lt;/destination&amp;gt; &amp;lt;encoder class=&quot;net.logstash.logback.encoder.LogstashAccessEncoder&quot;/&amp;gt; &amp;lt;/appender&amp;gt; &amp;lt;appender-ref ref=&quot;access&quot;/&amp;gt;&amp;lt;/configuration&amp;gt;TomcatContext Pipeline 추가@Configurationclass AccessLogConfig { @Bean fun addLogbackValve() = TomcatContextCustomizer { context -&amp;gt; javaClass.getResourceAsStream(&quot;/logback-access.xml&quot;).use { Files.createDirectories( (context.catalinaBase.toPath() .resolve(LogbackValve.DEFAULT_CONFIG_FILE)).parent ) Files.copy( it, context.catalinaBase.toPath() .resolve(LogbackValve.DEFAULT_CONFIG_FILE) ) } LogbackValve().let { it.isQuiet = true context.pipeline.addValve(it) } }}위 작업을 완료하면 아래 필드들이 수집되는것이 확인가능하다.TomcatContextPipeline을 추가하여 동작하도록 구현한 방식이라 서비스 영역의 커스텀이 불가한 단점이 존재하지만 특별히 커스텀이 불필요한 서비스의경우 빠르게 작업하기 좋다.&quot;@timestamp&quot;&quot;@version&quot;&quot;message&quot;&quot;method&quot;&quot;protocol&quot;&quot;status_code&quot;&quot;requested_url&quot;&quot;requested_uri&quot;&quot;remote_host&quot;&quot;content_length&quot;&quot;elapsed_time&quot;참조https://github.com/logfellow/logstash-logback-encoder" }, { "title": "Github action set-output is deprecated", "url": "/posts/githubaction-output/", "categories": "Dev, DevOps", "tags": "github, github-action", "date": "2023-01-27 00:00:00 +0900", "snippet": "AS-IS- name: Set output run: echo &quot;::set-output name={name}::{value}&quot;기본 Github action workflow에서 step의 output값을 추가 할 때 위 처럼 활용했는데 보안 이슈로 deprecatedTO-BE- name: Set output run: echo &quot;{name}={value}&quot; &amp;gt;&amp;gt; $GITHUB_OUTPUT" }, { "title": "Github action 종속 job의 결과에 따라 slack 전송", "url": "/posts/githubaction-needs-notify/", "categories": "Dev, DevOps", "tags": "github, github-action", "date": "2023-01-26 00:00:00 +0900", "snippet": "Needsworkflow 작성시 job의 종속job을 설정 할 수 있는 키워드이다.jobA: ~~jobB: ~~send-notify: needs: [ jobA, jobB ] # job A,B 가 모두 완료되야 실행된다원하는 조건에 따른 if 키워드 작성예시send-notify: needs: [ jobA, jobB ] runs-on: ubuntu-latest if: ${{ always() &amp;amp;&amp;amp; needs.jobA.result == &#39;success&#39; }} # jobA 성공 if: ${{ always() &amp;amp;&amp;amp; contains(join(needs.*.result, &#39;,&#39;), &#39;success&#39;) }} # 하나라도 success인 경우 if: ${{ always() &amp;amp;&amp;amp; !contains(join(needs.*.result, &#39;,&#39;), &#39;failure&#39;) }} # failure job이 하나도 없으면, skipped or canceled result 도 있으니 주의 steps: - name: Notify slack env: SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }} VERSION: ${{ needs.teardown.outputs.version }} uses: pullreminders/slack-action@master with: args: &#39;{\\&quot;channel\\&quot;:\\&quot;C1234567890\\&quot;,\\&quot;text\\&quot;:\\&quot;SUCCESS!!\\&quot;}&#39;참조Workflow syntax" }, { "title": "Kotlin AWS SESClient를 활용한 이메일 송신", "url": "/posts/java-ses/", "categories": "Dev, DevOps", "tags": "aws, ses, email", "date": "2022-10-20 00:00:00 +0900", "snippet": "SES?Amazon Simple Email Service 이며 온프레미스 환경에서 STMP 서버를 구축할 필요없이 관련 기능을 제공해주는 서비스 SES 환경설정하는부분은 생략한다. 매우 간단하니 직접 찾아보자.의존성(Kotlin DSL)implementation(platform(&quot;software.amazon.awssdk:bom:2.17.294&quot;))implementation(&quot;software.amazon.awssdk:ses&quot;)MainSenderclass MailSender { private val credential by lazy { AwsBasicCredentials.create( YOUR_ACCESS_KEY_ID, YOUR_SECRET_ACCESS_KEY ) } private val client by lazy { SesClient.builder() .region(Region.AP_NORTHEAST_2) .credentialsProvider(StaticCredentialsProvider.create(credential)) .build() } private fun wrapContent(raw: String) = Content.builder() .charset(&quot;UTF-8&quot;) .data(raw) .build() fun send(to: String, subject: String, body: String) { val dest = Destination.builder() .toAddresses(to) .build() val message = Message.builder() .subject(wrapContent(subject)) .body(Body.builder().html(wrapContent(body)).build()) .build() val request = SendEmailRequest.builder() .source(MY-EMAIL) // source는 SES에 등록된 식별자이여야 한다. .destination(dest) // sandbox 모드인 경우 SES에 등록된 이메일에게만 송신가능하다. .message(message) .build() client.sendEmail(request) }}" }, { "title": "Spring on AWS ECS Fargate, Prometheus, Grafana, ECS discovery service를 활용한 모니터링 환경 구축", "url": "/posts/ecs-promethues-grafana/", "categories": "Dev, DevOps", "tags": "aws, ecs, prometheus, grafana, monitoring", "date": "2022-08-12 00:00:00 +0900", "snippet": "들어가며본 글에서는 AWS ECS에 대한 모니터링 시스템을 Prometheus, Grafana를 활용하여 구축하는 방법에 대해 정리한다. ECS에 포함되는 많은 container중 spring boot micrometer(prometheus-registry)에 대한 모니터링을 구축하는 방법에 대해서만 정리한다.사전요구사항 prometheus, grafana에 대한 기본지식 Spring boot application on ECS fargate 2~5 instance micrometer 설정 작업완료 문제점 spring boot application이 포함된 service는 ELB를 통해 외부접근이 가능하다. 동일한 VPC에 monitoring instance를 따로 만들어서 ECS에서 구동중인 여러 spring instance에 대한 prometheus metric을 수집하고자 한다면 어떻게구현해야될까? 단순히 실행중인 모든 spring container의 private ip를 직접 prometheus static_config 값으로 사용하면 ECS 작업이 재실행되면 private ip는동적으로 재할당되므로 지속적인 수집이 불가능하다.ECS Discovery service?단순 EC2 instance의 경우 EC2 Discovery service를 활용하여 원하는 EC2 instance 목록을 획득할 수 있었는데 ECS의 fargate instance는 딱히 방법이 떠오르지않아리서치를 하다가 발견한 서비스!!!설정값에 따라 원하는 ECS container목록을 획득 할 수 있으며 이미 dockerhub에 image도 배포 되어있었다.미리보기 ECS discovery를 사용해서 prometheus targets를 획득하여 prometheus scrape format file_sd_configs format으로 저장 prometheus server에서는 획득한 promethus targets에 대한 지표를 수집한다. grafana에 prometheus datasource를 등록하고 원하는 dashboard를 통해 원하는 지표를 확인한다.구축 EC2 환경에서 docker-compose를 활용하여 작업EC2 수집대상 클러스터와 동일한 VPC에 위치 또는, VPC 피어링 설정(서로 다른 VPC에 위치한 private ip에 접근)이 되어있어야 한다. 보안그룹 Grafana(3000), Promethues(9090) port inbound open EC2 IAM role 설정 ECS discovery service에 필요하며 config를 통해 Access ID, Key값을 설정해도 가능.{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;ec2:DescribeInstances&quot;, &quot;ecs:Describe*&quot;, &quot;ecs:List*&quot; ], &quot;Resource&quot;: &quot;*&quot; } ]}Docker compose ymlversion: &#39;3.3&#39;networks: monitor-net: driver: bridgeservices: ecs-discovery: image: tkgregory/prometheus-ecs-discovery volumes: - ./output:/output environment: - AWS_REGION=$AWS_REGION command: - &#39;--config.write-to=/output/ecs_file_sd.yml&#39; - &#39;--config.cluster=$AWS_CLUSTER&#39; networks: - monitor-net prometheus: image: prom/prometheus:latest container_name: prometheus volumes: - ./prometheus:/etc/prometheus - ./output:/output command: - &#39;--config.file=/etc/prometheus/prometheus.yml&#39; - &#39;--storage.tsdb.path=/prometheus&#39; restart: unless-stopped ports: - &quot;9090:9090&quot; expose: - 9090 networks: - monitor-net grafana: image: grafana/grafana:latest container_name: grafana restart: unless-stopped ports: - &quot;3000:3000&quot; expose: - 3000 networks: - monitor-netprometheus ymlglobal: scrape_interval: 5s evaluation_interval: 15sscrape_configs: - job_name: &#39;prometheus&#39; static_configs: - targets: [ &#39;localhost:9090&#39; ] - job_name: &#39;ecs-discovery&#39; file_sd_configs: - files: - /output/ecs_file_sd.yml refresh_interval: 1mQuick starthttps://github.com/ColaGom/docker-monitoring-samplegit clone https://github.com/ColaGom/docker-monitoring-samplecd docker-monitoring-samplevim .env //setup your envdocker-compose up참조https://github.com/teralytics/prometheus-ecs-discoveryPrometheus-Configuration" }, { "title": "Spring 애플 로그인(oauth) 구현", "url": "/posts/spring-apple-auth/", "categories": "Dev, Spring", "tags": "spring, jpa, oauth, apple", "date": "2022-07-29 00:00:00 +0900", "snippet": "Sign in with apple server side Client에서 구현된 oauth webview or login sdk 를 활용하여 signin with apple authorization_code 획득 sign request with authorization_codeServer side authorization_code 를 통해 token 생성 요청 TokenResponse TokenResponse validate TokenResponse 에서 UserInfo 추출 4~7 과정의 내용을 정리사전준비 JWT 관련 기능은 auth0 library를 사용 Certificates, Identifiers &amp;amp; Profiles team-id client-id key-id private key file 모두 Apple developer console에서 획득 가능하다 주의사항 authorization_code is single-use only server-side authenticate이므로 Token verification 구현은 생략해도되나 참고용으로 작성결과class ApplePublicKeys( val keys: Array&amp;lt;ApplePublicKey&amp;gt;)data class ApplePublicKey( val alg: String, val e: String, val kid: String, val kty: String, val n: String, val use: String)data class TokenResponse( val accessToken: String, val expiresIn: Int, val idToken: String, val refreshToken: String, val tokenType: String)/** * Token generate에 사용할 client-secret은 ECDSA (비대칭 암호화) algorithm을 사용하여 * 생성해야된다. */class ExampleKeyProvider : ECDSAKeyProvider { private val PEM_URI = &quot;&quot; /** * singing 과정만 필요하므로 private key만 구현 */ override fun getPublicKeyById(keyId: String?): ECPublicKey? = null override fun getPrivateKey(): ECPrivateKey { val file = ResourceUtils.getFile(PEM_URI) PemReader(FileReader(file)).use { reader -&amp;gt; val content = reader.readPemObject().content return KeyFactory.getInstance(&quot;EC&quot;) .generatePrivate(PKCS8EncodedKeySpec(content)) as ECPrivateKey } } override fun getPrivateKeyId(): String? = null}object AppleAuthExample { private val rest by lazy { RestTemplate() } private val CLIENT_ID = &quot;&quot; private val TEAM_ID = &quot;&quot; private val KEY_ID = &quot;&quot; private const val AUTH_URL = &quot;https://appleid.apple.com&quot; fun createClientSecret(): String? { val now = Date() return JWT.create() .withHeader( mapOf( &quot;kid&quot; to KEY_ID ) ) .withSubject(CLIENT_ID) .withIssuer(TEAM_ID) .withIssuedAt(now) .withExpiresAt(Date(now.time + 1.hours.inWholeMilliseconds)) .withAudience(AUTH_URL) .sign(Algorithm.ECDSA256(ExampleKeyProvider())) } fun authenticate(authCode: String) { val headers = HttpHeaders().apply { contentType = MediaType.APPLICATION_FORM_URLENCODED } val map: MultiValueMap&amp;lt;String, String&amp;gt; = LinkedMultiValueMap&amp;lt;String, String&amp;gt;().apply { add(&quot;client_id&quot;, CLIENT_ID) add(&quot;client_secret&quot;, createClientSecret()) add(&quot;grant_type&quot;, &quot;authorization_code&quot;) add(&quot;code&quot;, authCode) } val entity = HttpEntity(map, headers) //authorization_code를 통해 token을 생성한다 val idToken = rest.exchange( &quot;https://appleid.apple.com/auth/token&quot;, HttpMethod.POST, entity, TokenResponse::class.java ).body?.idToken ?: throw RuntimeException(&quot;invalid or revoked authorization_code&quot;) val jwt = decodeIdToken(idToken) ?: throw RuntimeException(&quot;invalid idToken&quot;) if (!verifyToken(jwt)) throw RuntimeException(&quot;invalid idToken&quot;) /** * TODO: handle singing * jwt.subject is unique userId * jwt.getClaim(&quot;email&quot;) is user email */ } //Verify the JWS E256 signature using the server’s public key private fun decodeIdToken(token: String?): DecodedJWT? { val keys = rest.getForEntity(&quot;https://appleid.apple.com/auth/keys&quot;, ApplePublicKeys::class.java).body?.keys ?: return null keys.forEach { val nBytes: ByteArray = Base64.getUrlDecoder().decode(it.n) val eBytes: ByteArray = Base64.getUrlDecoder().decode(it.e) val modules = BigInteger(1, nBytes) val exponent = BigInteger(1, eBytes) val spec = RSAPublicKeySpec(modules, exponent) val kf: KeyFactory = KeyFactory.getInstance(&quot;RSA&quot;) val publicKey: RSAPublicKey = kf.generatePublic(spec) as RSAPublicKey try { return JWT.require( Algorithm.RSA256( publicKey, null ) ).build().verify(token) } catch (e: Exception) { } } return null } /** * https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/verifying_a_user */ private fun verifyToken(token: DecodedJWT): Boolean { //Verify that the time is earlier than the exp value of the token val verifyTime = Date() &amp;lt; token.expiresAt //Verify that the aud field is the developer’s client_id val verifyAud = token.audience.firstOrNull() == CLIENT_ID //Verify that the iss field contains https://appleid.apple.com val verifyIssuer = token.issuer == AUTH_URL return verifyTime &amp;amp;&amp;amp; verifyAud &amp;amp;&amp;amp; verifyIssuer }}참조Apple Developer Documentationhttps://github.com/auth0/java-jwt" }, { "title": "Spring: Entity OneToMany(일대다) 관계 정리", "url": "/posts/spring-otm-1/", "categories": "Dev, Spring", "tags": "spring, jpa, entity", "date": "2022-07-02 00:00:00 +0900", "snippet": "OneToMany위 처럼 일대다 관계를 가지는 Entity를 작성하는 방법과 차이점에 대한 정리기본 동작(by JoinTable)@Entityclass Student( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long, var name: String)@Entityclass Class( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long, @OneToMany var students: MutableSet&amp;lt;Student&amp;gt; = mutableSetOf())결과create table class ( id bigint generated by default as identity, primary key (id))create table class_students ( class_id bigint not null, students_id bigint not null, primary key (class_id, students_id))create table student ( id bigint generated by default as identity, name varchar(255), primary key (id))OneToMany관계는 기본적으로 JoinTable 기반으로 동작하며 생성되는 Table은 위와 같다.MappedBy자식(여기서는 student) entity에서 부모 entity의 정보를 포함하여 ManyToOne 관계를 구현@Entityclass Student( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long, var name: String, var classId: Long or @ManyToOne var `class`: Class)@Entityclass Class( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long, @OneToMany(mappedBy = &quot;classId&quot;) var students: MutableSet&amp;lt;Student&amp;gt; = mutableSetOf() or @OneToMany(mappedBy = &quot;class&quot;) var students: MutableSet&amp;lt;Student&amp;gt; = mutableSetOf())create table class ( id bigint generated by default as identity, primary key (id))create table student ( id bigint generated by default as identity, name varchar(255), class_id bigint not null, primary key (id))Query 비교INESRT - JOIN TABLEval `class` = classRepository.save(Class())val students = studentRepository.saveAll( mutableListOf( Student(name = &quot;a&quot;), Student(name = &quot;b&quot;), Student(name = &quot;c&quot;), )).toMutableSet()`class`.students = studentsHibernate: insert into class (id) values (default)Hibernate: insert into student (id, name) values (default, ?)Hibernate: insert into student (id, name) values (default, ?)Hibernate: insert into student (id, name) values (default, ?)Hibernate: insert into class_students (class_id, students_id) values (?, ?)Hibernate: insert into class_students (class_id, students_id) values (?, ?)Hibernate: insert into class_students (class_id, students_id) values (?, ?)INESRT - MappedByval `class` = classRepository.save(Class())val students = studentRepository.saveAll( mutableListOf( Student(name = &quot;a&quot;, `class` = `class`), Student(name = &quot;b&quot;, `class` = `class`), Student(name = &quot;c&quot;, `class` = `class`), )).toMutableSet()`class`.students = studentsHibernate: insert into class (id) values (default)Hibernate: insert into student (id, class_id, name) values (default, ?, ?)Hibernate: insert into student (id, class_id, name) values (default, ?, ?)Hibernate: insert into student (id, class_id, name) values (default, ?, ?) FetchType은 따로 지정하지않고 기본값(LAZY)으로 비교진행SELECT - JOIN TABLEHibernate: select class0_.id as id1_0_0_ from class class0_ where class0_.id=?Hibernate: select students0_.class_id as class_id1_1_0_, students0_.students_id as students2_1_0_, student1_.id as id1_2_1_, student1_.name as name2_2_1_ from class_students students0_ inner join student student1_ on students0_.students_id=student1_.id where students0_.class_id=?SELECT - MappedByHibernate: select class0_.id as id1_0_0_ from class class0_ where class0_.id=?Hibernate: select students0_.class_id as class_id3_1_0_, students0_.id as id1_1_0_, students0_.id as id1_1_1_, students0_.class_id as class_id3_1_1_, students0_.name as name2_1_1_ from student students0_ where students0_.class_id=?" }, { "title": "Spiring: ManyToMany 관계 Entity에서 컬럼 추가", "url": "/posts/spring-mtm/", "categories": "Dev, Spring", "tags": "spring, jpa, entity", "date": "2022-07-01 00:00:00 +0900", "snippet": " 본 글에 포함된 엔티티 정의는 이해를돕기위한 예시입니다.Simple ManyToMany Relation위 Relation을 가지는 Entity를 정의할때, 아래 예시처럼 Recommend Entity에서 ManyToMany 관계를 작성하여 설정이 가능하다.class Recommend( @ManyToMany( fetch = FetchType.LAZY, cascade = [CascadeType.ALL] ) @JoinTable( name = &quot;song_recommend&quot;, joinColumns = [JoinColumn(name = &quot;recommend_id&quot;)], inverseJoinColumns = [JoinColumn(name = &quot;song_id&quot;)] ) var songs: MutableSet&amp;lt;Song&amp;gt;? = null, ... @JoinTable( name = &quot;movie_recommend&quot;, joinColumns = [JoinColumn(name = &quot;recommend_id&quot;)], inverseJoinColumns = [JoinColumn(name = &quot;movie_id&quot;)] ) var movies: MutableSet&amp;lt;Movie&amp;gt;? = null,)추가 컬럼이 필요할 때위 예시에서 추천 대상 엔티티의 컬럼(song, enitty)외에 추천관련 정보가 추가로 필요한 경우 JoinTable만 사용해서는 구현이 불가하다.해결방안여러 방법이 있겠지만 본 글에서는 JoinTable Entity를 직접 작성하여 원하는 정보를 추가하는 방식으로 진행.요구하는 관계 다이어그램은 아래와 같다.Entity@Embeddabledata class RecommendSongId( @Column(name = &quot;recommend_id&quot;) var recommendId: Long, @Column(name = &quot;song_id&quot;) var songId: Long) : Serializable@Entityclass RecommendSong( @EmbeddedId var id: RecommendSongId, @ManyToOne @MapsId(&quot;recommend_id&quot;) var recommend: Recommend? = null, @ManyToOne @MapsId(&quot;song_id&quot;) var song: Song? = null, var extra: Int = 0, ...)@Entityclass Recommend( ... @OneToMany(mappedBy = &quot;recommend&quot;, cascade = [CascadeType.ALL], orphanRemoval = true) var songs: MutableSet&amp;lt;RecommendSong&amp;gt; = mutableSetOf() ...)예제에는 composite key(RecommendSongId)를 사용했지만 RecommendSong에 PK, FK(recommend, song) 을 작성하는 방식으로도 구현가능하다" }, { "title": "Spring: gradle kotlin dsl jar파일 빌드", "url": "/posts/kotlindsl-jar/", "categories": "Dev, Spring", "tags": "spring, gradle, jar", "date": "2022-06-09 00:00:00 +0900", "snippet": "문제kotlin dsl gradle 아래처럼 작성 후 build task 진행시 jar가 생성되지 않는문제가 발생tasks { named&amp;lt;Jar&amp;gt;() { enabled = false } named&amp;lt;BootJar&amp;gt;(&quot;bootJar&quot;) { archiveName = &quot;mercury&quot; }}해결방안kotlin dsl 의 named 함수는 inline이며 name인자를 넘기지않으면 단순히 Jar type의 Task(BootJar task)를 리턴하므로 정상 동작을 하지않는다.named&amp;lt;Jar&amp;gt;(&quot;jar&quot;) { enabled = false}named&amp;lt;BootJar&amp;gt;(&quot;bootJar&quot;) { archiveName = &quot;mercury.jar&quot;}참조https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives" }, { "title": "Spring: Mapstruct SubclassMapping 사용법", "url": "/posts/spring-mapstruct/", "categories": "Dev, Spring", "tags": "spring, mapstruct", "date": "2022-06-08 00:00:00 +0900", "snippet": "Mapstruct?class mapping을 구현하기위해 주로 ModelMapper를 사용했었는데 퍼포먼스 이슈(특히 nested + polymorphic collection)가 있어서 대체제를 찾던중 codegen 방식의 MapStruct를 발견하여 채택reflection 기반의 ModelMapper와 달리 annotation processing 과정에서 Mapper class를 생성해주는 방식이라 퍼포먼스가 훌륭하다. 현재 기준 최신버전인 1.5.x.Final 기준으로 작성되었으며 전버전(1.4.x.Final) 대비 많은 기능(SubclassMapping, Map to bean, Conditional Mapping 등) 이 추가되고 codegen 과정의 최적화가 진행되었다.(추천)codegen?class UserEntity( val name: String, val email: String)class UserDto( val name: String, val email: String)@Mapperinterface UserMapper { fun map(entity: UserEntity): UserDto fun map(dto: UserDto): UserEntity}//Genereted codepublic class UserMapperImpl implements UserMapper { @Override public UserDto map(UserEntity entity) { ... } @Override public UserEntity map(UserDto dto) { ... }}generated code를 보면 @Mapper annotation을 붙인 interface의 signature에 따라 적절한 mapping 함수를 생성해준다.SubclassMappingEntity &amp;amp; Dto@Entity@Inheritanceclass AnimalEntityclass CatEntity : AnimalEntityclass DogEntity : AnimalEntity// DTOclass Animalclass Cat : Animalclass Dog : AnimalMapper/** ComponentModel.SPRING을 지정하면 @Component이 추가된다.* 따라서, bean(DI)를 통해 주입받아 사용 가능하다.*/@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)interface AnimalMapper { @SubclassMappings( SubclassMapping(source = CatEntity::class, target = Cat::class), SubclassMapping(source = DogEntity::class, target = Dog::class) ) fun map(entity: AnimalEntity): Animal fun map(entities: List&amp;lt;AnimalEntity&amp;gt;): List&amp;lt;Animal&amp;gt;}Service@Serviceclass AnimalService( private val mapper: AnimalMapper, private val repository: AnimalRepository) { fun all(): List&amp;lt;Animal&amp;gt; = repository.findAll().let(mapper::map)}주의사항 kotlin 환경에서 isXXX 또는 hasXXX이름을 가지는 boolean property는 mapping시 해당 값이 무시되는 문제가 있다.원인source.isA() getter 는 target.a property 로 mapping code가 생성되는데 kotlin/jvm 구현상 traget의 property 또한 isA로 생성되기때문에 mismatching해결방안직접 mapping annotation을 작성하거나 is 또는 has 접두사를 사용을 피할 것data class Foo( val isA: Boolean)data class Bar( val isA: Boolean)@Mapperinterface FooBarMapper { fun map(foo: Foo): Bar // not work @Mapping(target = &quot;isA&quot;, source = &quot;a&quot;) fun map(foo: Foo): Bar}Referencehttps://mapstruct.org/documentation/stable/reference/html/" }, { "title": "안드로이드 자동배포(CI&amp;CD) 구현 with GithubAction, AWS S3, Slack", "url": "/posts/githubaction-deploy/", "categories": "Dev, CI&CD", "tags": "github-action, aws, kmm", "date": "2022-05-20 00:00:00 +0900", "snippet": "목표 github에 새로운 release가 생겼을 때 signed apk(release)를 생성하여 AWS S3에 업로드하고 관련 메세지를 slack에 전송한다.해결하고자하는 것 기존에도 s3에 debug apk를 업로드하게 구현해뒀으나, 실제 배포환경과 동일한 테스트를 위해 signing apk 배포 필요 post signing 고정 URL의 S3에 업로드하는방식은 테스트 버전 파악이 쉽지않다. version name with release 적용. 새로운 버전이 release 되었을때 notify Slack APK 설치가 쉽지않다. QR code &amp;amp; Action button Workflow 작성1. 환경 변수 설정- name: Set vars id: vars run: | IFS=&#39;/&#39; TAG=&quot;${GITHUB_REF#refs/*/}&quot; read -a strarr &amp;lt;&amp;lt;&amp;lt; &quot;$TAG&quot; echo ::set-output name=tag::$TAG echo ::set-output name=platform::${strarr[0]} echo ::set-output name=version::${strarr[1]} echo ::set-output name=filename::**[업로드할 파일이름]**-${strarr[1]}.apkgithub action에서 사용할 변수들을 미리 설정해주는 방식으로 작업.TAG에 release tag값이 지정되며 이를 활용하여 필요한 변수들 저장2. Signing APK- name: Signing APK id: sign_app uses: r0adkll/sign-android-release@v1 with: releaseDirectory: androidApp/build/outputs/apk/release signingKeyBase64: $ alias: $ keyStorePassword: $ keyPassword: $keystore 자체를 repository에 넣어두고 signing을 할 수 있으나 보안상 apk build 후 따로 signing을 진행하는 식으로 작업 assembleRelease시 signing을 진행하는 경우 생략전체 Workflowname: Android Deployon: workflow_dispatch: push: tags: &#39;aos/*&#39;env: GITHUB_URL: **[~~~]** AWS_REGION: ap-northeast-2jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set vars id: vars run: | IFS=&#39;/&#39; TAG=&quot;${GITHUB_REF#refs/*/}&quot; read -a strarr &amp;lt;&amp;lt;&amp;lt; &quot;$TAG&quot; SIZE=${#strarr[*]} echo $TAG echo ::set-output name=tag::$TAG echo ::set-output name=platform::${strarr[0]} echo ::set-output name=version::${strarr[1]} echo ::set-output name=filename::**[~~~]**-${strarr[1]}.apk - name: set up JDK 11 uses: actions/setup-java@v3 with: java-version: &#39;11&#39; distribution: &#39;temurin&#39; cache: gradle - name: Grant execute permission for gradlew run: chmod +x ./gradlew - name: Build Release APK with Gradle run: ./gradlew :androidApp:assembleRelease - name: Signing APK id: sign_app uses: r0adkll/sign-android-release@v1 with: releaseDirectory: androidApp/build/outputs/apk/release signingKeyBase64: $ alias: $ keyStorePassword: $ keyPassword: $ - name: Rename apk run: mv $ $ - name: Upload apk to s3 id: upload uses: hkusu/s3-upload-action@v2 with: aws-access-key-id: $ aws-secret-access-key: $ aws-region: $ aws-bucket: $ file-path: $ bucket-root: &#39;/&#39; destination-dir: &#39;android&#39; output-file-url: &#39;true&#39; output-qr-url: &#39;true&#39; qr-width: 500 public: &#39;true&#39; - name: Notify slack env: SLACK_BOT_TOKEN: $ S3_URL: $ QR_URL: $ CHANGE_URL: $releases/tag/$ uses: pullreminders/slack-action@master with: args: &#39;{\\&quot;channel\\&quot;: ~~~&#39;SlackBlock kit을 사용하여 원하는 message payload를 구현하여 전달Referenceshttps://github.com/r0adkll/sign-android-releasehttps://app.slack.com/block-kit-builder" }, { "title": "AWS: Typescript + serverless aws lambda 배포", "url": "/posts/ts-lambda/", "categories": "Dev, Serverless", "tags": "aws, serverless, type-script", "date": "2022-04-28 00:00:00 +0900", "snippet": "목적 nodejs 환경에서 TypeScript로 작성된 어플리케이션을 serverless framework를 활용하여 람다에 배포요구사항 REST + AWSGatewayProxy POST with json body API KEY 기반 인증 local 환경에서의 테스트 람다 함수 내부에서 API 외부 호출 (node-fetch)본 글에서는 yarn을 활용하여 의존성 관리를 진행한다.Serverless 설치npm install -g serverless의존성 설정yarn inityarn add @types/aws-lambdayarn add serverless-plugin-typescriptyarn add serverless-offline -D... #add optional dependencies어플리케이션 작성 index.tsapi-gateway proxy를 통해 넘어오는 event값 내용을 확인export async function echo( event: APIGatewayProxyEventV2): Promise&amp;lt;APIGatewayProxyResultV2&amp;gt; { const requestBody = JSON.parse(event.body ?? &quot;&quot;) // aws gateway proxy를 통해 넘어온 event의 body값을 통해 request body를 획득 return { statusCode: 200, data: JSON.stringify(event) }}Serverless ymlservice: {SERVICE_NAME_FOR_LAMBDA_APPLICATION}plugins: - serverless-plugin-typescript # 필수 - serverless-offlineprovider: name: aws runtime: nodejs14.x region: ap-northeast-2functions: metadata: handler: src/index.echo events: - http: path: echo method: post private: true # API 인증 활성화Offline testserverless offline...│ POST | http://localhost:3000/dev/echo │...ResponsePostman을 사용하여 json body를 입력하고 POST 요청을 보내면 아래와 같은 결과 획득{ &quot;resource&quot;: &quot;/echo&quot;, &quot;path&quot;: &quot;/echo&quot;, &quot;httpMethod&quot;: &quot;POST&quot;, &quot;body&quot;: ... ...}Deployserverless deploy...endpoint: POST - https://~~~/dev/echofunctions: echo: ......위처럼 배포가 진행되고 완료되면 api endpoint와 배포된 람다 함수 목록을 확인 할 수 있다.serverless.yml events에 private 설정을 안해뒀으면 바로 endpoint 호출이 가능하다.API 키 생성 및 설정이후 생성된 aws api gateway console에 접속하여 좌측 탭의 API 키 &amp;gt; 작업 &amp;gt; API 생성 및 사용량 계획을 생성하여 설정해주면 생성된 api key값을 헤더x-api-key에 추가하여 요청이 가능하다." }, { "title": "Spring: Querydsl 환경설정 및 용례", "url": "/posts/querydsl-basic/", "categories": "Dev, Spring", "tags": "spring, querydsl", "date": "2022-04-06 00:00:00 +0900", "snippet": "QueryDsl?HQL(JPQL) 또는 native SQL을 사용 할 때 런타임에서만 query validation이 가능한 문제가 있다. JPA 2.0 부터 Criteria Query API가 제공되긴하지만 복잡한 쿼리를 작성하기에는 한계점이 있고 작성한다 해도 가독성이 매우 떨어지는 형태가 된다.이러한 ORM framework의 문제점들을 해결하는데 목적을두는 라이브러리.Setup dependencyimplementation &#39;com.querydsl:querydsl-jpa&#39;annotationProcessor &quot;com.querydsl:querydsl-apt:${dependencyManagement.importedProperties[&#39;querydsl.version&#39;]}:jpa&quot;annotationProcessor &quot;jakarta.persistence:jakarta.persistence-api&quot;annotationProcessor &quot;jakarta.annotation:jakarta.annotation-api&quot;Dsl Config@RequiredArgsConstructor@Configurationpublic class QuerydslConfig { private final EntityManager em; @Bean public JPAQueryFactory queryFactory() { return new JPAQueryFactory(em); }}UseCase연관관계가 없는 두 entity(User, UserEmail)을 조회해서 DTO로 결과값을 만들어보기(일반적으로 OneToOne relation이 존재하겠지만 join을 활용하는 예시를 위해 설정)Entity@Entitypublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; private long userId; ...}@Entitypublic class UserEmail { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; ...}DTOimport com.querydsl.core.annotations.QueryProjection;public class UserDto { private long id; private String name; private String email; public MemberDto() { } @QueryProjection public MemberDto(long id, String name, String email) { this.id = id; this.name = name; this.email = email; }}UseCase@Repositorypublic class UserRepository extends QuerydslRepositorySupport { private final JPAQueryFactory qf; public UserDto get(long userId) { return qf.select(new QUserDto(user.id, user.name, uesrEmail.email)) .from(uesr) .join(userEmail).on(user.id.eq(userEmail.userId)) .where(user.id.eq(userId)) .fetchOne(); }}" }, { "title": "Kotlinx-serialization: PolymorphicSerializer", "url": "/posts/kotlinx-polymorphic/", "categories": "Dev, Android", "tags": "android, kmm, kotlinx", "date": "2022-03-28 00:00:00 +0900", "snippet": "들어가며본 글에서는 kotlinx-serialization을 사용할 때 Custom Serializer - PolymorphicSerializer 를 사용하는 방법에 대한 정리.retrofit에서 CustomConvertor를 추가하는 내용과 동일한 목적을 가진다.PolymorphicObjectinterface IPolymorhicType { val type: String}data class First( override val type: String = &quot;F&quot;, ...) : IPolymorhicTypedata class Second( override val type: String = &quot;S&quot;, ...) : IPolymorhicType위 처럼 주어진 type에 따라 First 또는 Second property를 가지는 model이 있을때 적용하는 사용하는 방법Add Serializable@Serializabledata class First(...) : IPolymorhicType@Serializabledata class Second(...) : IPolymorhicTypeSerializer implementsobject MySerializer : JsonContentPolymorphicSerializer&amp;lt;IPolymorhicType&amp;gt;(IPolymorhicType::class) { override fun selectDeserializer(element: JsonElement) = when (element.jsonObject[&quot;type&quot;]?.jsonPrimitive?.content) { &quot;F&quot; -&amp;gt; First.serializer() else -&amp;gt; Second.serializer() }}@Serializabledata class Parent( @Serializable(with = MySerializer::class) val data: IPolymorhicType, ...)" }, { "title": "Android: Compose Text dp 적용하기", "url": "/posts/compose-text-dp/", "categories": "Dev, Android", "tags": "android, compose", "date": "2022-03-02 00:00:00 +0900", "snippet": "Dp for TextUI 디자인상 sp unit을 적용하지 못하는 영역이 있다.(최대한 피해야되긴하지만..)하지만, Compose의 Text에서 사용되는 fontSize unit이 sp로 고정되어있어 dp 값을 사용할 수 없다.이를 해결하기위해 주어진 dp값을 sp값으로 변환하여 사용하는 방법 정리Extensions@Composablefun TextStyle.fixed() = with(LocalDensity.current) { copy(fontSize = Dp(fontSize.value).toSp()) }val Int.dsp @Composable get() = with(LocalDensity.current) { Dp(toFloat()).toSp() }UseText( ... fontSize = 11.dsp)Text( ... style = style.fixed())" }, { "title": "선언형 UI 개론", "url": "/posts/declarative-intro/", "categories": "Dev", "tags": "android, compose", "date": "2022-02-25 00:00:00 +0900", "snippet": "Declarative vs Imperative본글에서는 선언형 UI에 대한 정의와 명령형 UI와의 차이점과 장점에대해 정리해보고자한다.Simple Login Button현재 로그인상태의 유저의 경우 profile 이미지와 alarm badge를 보여주고비로그인상태면 로그인 버튼을 노출하는 간단한 UI를 구현한다고 가정해보자Imperative UIfun updateUI(user: User?) { btnLogin.isVisible = false imageProfile.isVisble = false alarmBadge.isVisible = false if(isLoggedIn) { imageProfile.isVisible = true imageProfile.loadImage(profileUrl) if(user.newAlarmCount &amp;gt; 0) { alarmBadge.isVisble = true alarmBadge.text = user.newAlarmCount } return } btnLogin.isVisible = true}명령형 UI로 작성할때 일반적으로 많이 사용하던 방식이며 View state 초기화 → 현재 상태 반영 순으로 작성했다.Declarative UI@Composablefun UserUI(user : User?) { if(user == null) { LoginButton() return } Image(painter = /* painter by profileUrl */) AlarmBadge(alarmCount = user.newAlarmCount)}선언형 UI의 경우 현재 State에 대한 UI만 작성해주면 되는식으로 훨씬 간결해지고 UI 구조를 파악하기도 좋다.아주 간단한 로직을 구현하는 UI임에도 차이가 크며 구현하는 뷰 로직의 복잡도가 증가 할 수도록 두 방법의 구현 복잡도에는 큰 차이가 발생한다. 즉, 선언형 UI의 경우 View의 이전 상태에는 신경쓰지않고 순수하게 View State에 대한 UI만 잘 작성해두면 나머지는 Framework에서 처리해주는 방식이다.이 좋은걸 이제서야?그럼 진작에 선언형 UI로 프레임워크를 구현하면되는데 왜 이제서야 이렇게 사용되고있는가? 많은 이유가있겠지만 필자가 생각하기에 선언형 UI의 특성상 State가 갱신되면 View의 최상위(root)부터 갱신(선언) 되는데 이 때 갱신이 필요한 Layout node만 식별하고 갱신하는 메커니즘을 구현하고 관련 기능을 프레임워크 레벨에서 하는것이 쉽지않으며 해당 메커니즘의 최적화가 부족한 경우 명령형 UI와 비교해서 퍼포먼스 이슈가 크게 발생하므로 이렇게 시간이 오래걸린게 아닌가 싶다. (Reactive, Flutter, Swift 등의 대표적인 선언형 UI 프레임워크들의 초기버전을 생각해보면 퍼포먼스 이슈가 상당했던걸 보면… 아마도?)결론위에 작성한 차이점말고도 View 캡슐화, 단방향 data flow등 선언형 UI를 사용하는경우 효과적이고 보다 안전하게 UI 코드를 작성할 수 있으며 이 때문에 수년간 Compose framework를 기획하고 오픈소스화하는 노력을 통해 완성도 높은 프레임워크를 구현하였다고 한다." }, { "title": "Android: Compose TextField wrap content", "url": "/posts/compose-textfiled-wrap/", "categories": "Dev, Android", "tags": "android, compose", "date": "2022-02-22 00:00:00 +0900", "snippet": "TextField wrap contentTextField UI의 경우 일반적으로 Fixed width로 디자인되나, 간혹 wrap_content처럼 작성한 text에 따른 width를 가지는 구현이 필요할 때가있다.이 때, EditText에서는 wrap_content attribute를 활용하여 해결되지만 Compose의 TextField에서는 따로 방법이 없어 해결한 방법에 대한 정리Compose TextFieldCompose의 TextField에서 사용하는 Composable인 CoreTextField의 구현을 살펴보면 Paragraph width값으로 layout width를 계산하고있으며, 이때 modifier의 Intrinsic값을 활용하는것을 알 수 있다.따라서, 해당 값을 수정하여 원하는 layout을 구현 할 수 있다.BasicTextField( modifier = Modifier.width(IntrinsicSize.Min), ...)" }, { "title": "Android: Compose Custom Layout - Quad Layout", "url": "/posts/compose-quad/", "categories": "Dev, Android", "tags": "android, compose", "date": "2022-02-18 00:00:00 +0900", "snippet": "QuadLayout?자식 View개수에 따라 전체 영역을 4분할 하여 노출해주는 뷰를 구현해보자. 약간만 수정하면 2,3개인경우 빈공간을 PlaceHolder로 채워주는 형태로 수정가능하니 참고.단일 아이템아이템 4개구현@Composablefun Quad( modifier: Modifier, gap: Dp = 1.dp, content: @Composable () -&amp;gt; Unit,) { Layout( modifier = modifier, content = content ) { measurable, constraints -&amp;gt; check(measurable.size &amp;lt; 5) { &quot;must quad item size 4 or less&quot; } layout(constraints.maxWidth, constraints.maxHeight) { val eachWidth = if (measurable.size &amp;lt; 2) constraints.maxWidth else constraints.maxWidth / 2 val eachHeight = if (measurable.size &amp;lt; 2) constraints.maxHeight else constraints.maxHeight / 2 val childConstraint = Constraints.fixed(eachWidth, eachHeight) val gapPx = gap.roundToPx() measurable.map { it.measure(childConstraint) } .forEachIndexed { index, placeable -&amp;gt; val x = (index % 2) * (eachWidth + gapPx) val y = (index / 2) * (eachHeight + gapPx) placeable.placeRelative(x, y) } } }}@Preview@Composableprivate fun PreviewQuadWithSingle() { Quad(modifier = Modifier.size(140.dp)) { Box(modifier = Modifier.background(Color.Red)) }}@Preview@Composableprivate fun PreviewQuadWithQuad() { Quad(modifier = Modifier.size(140.dp)) { Box(modifier = Modifier.background(Color.Red)) Box(modifier = Modifier.background(Color.White)) Box(modifier = Modifier.background(Color.Green)) Box(modifier = Modifier.background(Color.Yellow)) }}" }, { "title": "Android: Compose Custom Layout - Basic", "url": "/posts/compose-layout/", "categories": "Dev, Android", "tags": "android, compose", "date": "2022-02-14 00:00:00 +0900", "snippet": "Intro이번 글에서는 Compose의 Layout에 대한 정리와 대표적인 Custom Layout 사용방법에 대해 정리한다. Composable함수는 Composer를 통해 Composition이 진행된다. 이때 ElementTree(contained CompositionData)가 생성되며 이를 통해 Layout → Drawing 과정을 거쳐 UI Rendering이 이뤄진다. Compose는 Kotlin-Multiplatform Base로 구현되며 내부 구현(Composable 함수가 컴파일 단계에서 IR과정을 거쳐 컴포즈 함수로 변환되는 과정과 이를 토대로 NodeTree를 구성하고 플랫폼별 Layout, Render(Drawing) 과정을 구현한 내용을 보면 놀랍다. 추후 하나씩 정리해보도록하자.Layout?Composition과정을 거쳐 생성되는 ElementTree(이하 Tree)의 measuring 과정이며 Tree의 값에따라 measuring skip을 구현하여 최적화를 지원한다.간단하게 Layout이 진행되는 과정을 정리하면 아래와같다.has Child then Child.mesaure else size -&amp;gt; placeSooooo simple, 자식이 존재하면 재귀적으로 동작한다고 이해하면 쉬우며 최상위(root) node부터 최하위 노드까지 measure함수가 호출되며 최하위 노드의 size(크기)와 place(위치)를 통해 각 node 별 Coordinate값이 결정된다. (실제 구현이 recursive는 아니다)즉, 자식 노드의 coordinate값이 먼저계산되고 이를 토대로 부모 노드의 coordinate값이 계산되는 방식이다. 해당 과정을 적절하게 커스텀하여 원하는 Layout을 얼마든지 쉽게 구현할 수 있으며 ConstraintLayout등과 같은 Layout은 불필요하다.Custom Layout - ComposedBox위와같은 UI 구현이 필요할때, Layout을 활용해보자.@Composablefun ComposedBox( modifier: Modifier = Modifier, bottomContent: @Composable () -&amp;gt; Unit, content: @Composable () -&amp;gt; Unit) { Layout( modifier = modifier, content = { content() bottomContent() }) { measurable, constraints -&amp;gt; val box = measurable[0].measure(constraints) val bottom = measurable[1].measure(constraints) layout(width = box.width, height = box.height + bottom.height / 2) { box.placeRelative(0, 0) bottom.placeRelative(0, box.height - bottom.height / 2) } }}@Preview@Composableprivate fun PreviewComposedBox() { ComposedBox( bottomContent = { Box( modifier = Modifier .size(50.dp) .background(Color.Red) ) }, content = { Box( modifier = Modifier .size(100.dp) .background(Color.Blue) ) } )}간단한 구현이며, content와 bottomContent를 받아 예시형태로 배치한다.content가 2개뿐이라 measurable의 index로 접근했지만 아래처럼 layoutId 값을 기준으로 measurable 을 획득 할 수 있다.measurable.find{ it.layoutId== &quot;id&quot;}?.let{ }결론이를 활용하면 Compose ContraintLayout의 활용없이 손쉽게 원하는 배치의 UI를 구현 할 수 있으니 참고하자.ReferenceAndroid - layout" }, { "title": "Android: ComposeView inside CoordinatorLayout (ComposeView CoordinatorLayout에서 사용하기)", "url": "/posts/compose-coordinator/", "categories": "Dev, Android", "tags": "android, compose", "date": "2022-02-06 00:00:00 +0900", "snippet": "ComposeView inside CoordinatorLayout100% ComposeView로 작성한 앱은 발생하지 않을 문제이긴하나 위 레이아웃 구조 처럼 AndroidView와 ComposeView를 섞어서쓰는경우 ComposeView에서 발생한 scrollView 이벤트를 CoordiantorLayout에 전파하는 방법에대해 정리Touch propagationAndroidViewmain doCallback- MessageQueue.next - InputEventRecevier.dispatchInputEvent() - ViewRoot.enqueueEvent() - View.dispatchPointerEvent() - DecorView.dispatchTouchEvent() - Activity.dispatchTouchEvent() - ViewGroup.dispatchTouchEvent() - TargetView.onInterceptTouchEvent() - if nested widget THEN startNestedScroll()dispatchTouchEvent, onInterceptTouchEvent, onTouchEvent 의 chaning 으로 처리되는 touch event 자세한 내용은 skipComposeView dispatchTouchmain doCallback- MessageQueue.next - InputEventRecevier.dispatchInputEvent() - ViewRoot.enqueueEvent() - View.dispatchPointerEvent() - DecorView.dispatchTouchEvent() - Activity.dispatchTouchEvent() - ViewGroup.dispatchTouchEvent() - AndroidComposeView - dispatchTouchEvent - handleTouchEvent - PointerInputEventProcesser.process - ...AndroidComposeView 까지의 touch propagation과정은 동일하나 이후 Compose framework에서 자체적으로 제공되는 touchEvent 처리방식을 통해 이벤트 처리가 진행된다. 해당 방식과 AndroidView의 touchEvent를 처리하는 방식은 data struct부터 touch event를 처리하는 value 등 다른게 구현된 부분이 대부분이며 AndroidView와의 compatibility를 지원하지 않는다.문제점 ComposeView의 nestedScroll 동작이 필요하다.해결방안 (proto typing LazyColumn) 단순 가능여부를 판단하기위한 테스트이며 실제 프로덕트에 적용하면 사이드 발생가능성이…가장 좋은방법은 100% ComposeView를 활용하여 구현하는것이다. (마이그레이션은..?)dispatch compose nested scroll eventLazyColumn, Pager등에서 사용되는 NestedScrollConnection와 NestedScrollingChildHelper를 구현하여 테스트 진행.Compose의 touch event를 처리하는데 사용하는 값(consumed, available 등)은 AndroidView와 반대로 계산된다. 따라서, -값으로 childHelper에 전달.val listState = rememberLazyListState()val childHelper = remember { NestedScrollingChildHelper(requireView()).apply { isNestedScrollingEnabled = true }}if (listState.isScrollInProgress) { DisposableEffect(Unit) { childHelper.startNestedScroll(SCROLL_AXIS_VERTICAL) onDispose { childHelper.stopNestedScroll() } }}val scrollConnection = remember { object : NestedScrollConnection { override suspend fun onPostFling( consumed: Velocity, available: Velocity ): Velocity { childHelper.dispatchNestedFling( -consumed.x, -consumed.y, false ) return super.onPostFling(consumed, available) } override fun onPostScroll( consumed: Offset, available: Offset, source: NestedScrollSource ): Offset { childHelper.dispatchNestedScroll( -consumed.x.toInt(), -consumed.y.toInt(), -available.x.toInt(), -available.y.toInt(), null ) return super.onPostScroll(consumed, available, source) } override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset { childHelper.dispatchNestedPreScroll( -available.x.toInt(), -available.y.toInt(), reusableIntPair, null ) return super.onPreScroll(available, source) } override suspend fun onPreFling(available: Velocity): Velocity { childHelper.dispatchNestedPreFling( -available.x, -available.y, ) return super.onPreFling(available) } }} AppBar, BottomNav behaviour등은 문제없이 동작하는 부분은 확인하였으나 ExpandableToolbar등의 동작은 확인하지 못하였다." }, { "title": "Android: Nested Coordinator Layout (중첩 CoordinatorLayout)", "url": "/posts/nested-coordinator/", "categories": "Dev, Android", "tags": "android", "date": "2022-02-04 00:00:00 +0900", "snippet": "들어가며본 글에서는 중첩된 CoordinatorLayout을 사용하는 경우 ChildCoordinator의 unconsumed scroll event를 ParentCoordinator로 전파하는 방법에대하여 정리Nested ScrollEvent 전파짧게 정리하자면 NestedScrollingChild에서 발생한 scroll event NestedScrollingParent로 전파되며 이때 전달되는 consumed, unconsumed x,y값을 활용하여 nested scroll을 구현한다. 이때 NestedScrollingParent, Child interface가 사용되며 compatibility를 위해 Parent, Parent2, Child1, Child2, Child3등의 interface가 존재한다.예시흔히 볼수있는 CoordinatorLayout 구조이며 위 구조에서 RecyclerView(NestedScrollingChild)의 스크롤 이벤트 발생시 CoordinatorLayout(NestedScrollingParent)으로 이벤트가 전파되며 CoordinatorLayout에서는 포함된 Chlid View의 Behavior에 해당 이벤트를 전파한다.//in CoordinatorLayout.onStartNestedScrollfinal LayoutParams lp = (LayoutParams) view.getLayoutParams();final Behavior viewBehavior = lp.getBehavior();if (viewBehavior != null) { final boolean accepted = viewBehavior.onStartNestedScroll(this, view, child, target, axes, type); handled |= accepted; lp.setNestedScrollAccepted(type, accepted);} else { lp.setNestedScrollAccepted(type, false);}NestedCoordinatorLayout 문제만약 위처럼 CoordinatorLayout이 중첩된 Layout을 구현한다면 inner Coordinator의 스크롤이 발생해도 outer Coordinator에는 스크롤이 전파되지 않는 문제. 위 예시에서는 이해를 돕기위해 AppBar, BottomNavigation으로 명시했으나 CoordinatorLayout.Behavior을 구현한 많은 컴포넌트가 포함되는 경우가 일반적이다.해결방법앞서 정리해본 내용을 토대로 생각해보면, CoordinatorLayout은 NestedScrollingParent이므로 내부의 Behaviour에는 스크롤 이벤트가 정상적으로 전파되나 부모 CoordinatorLayout에는 전파되지 않는다.여기서 자식 CoordinatorLayout에서 NestedScrollingChild를 구현하면 부모 CoordinatorLayout에게 이벤트를 전파 할 수 있다.class NestedCoordinatorLayout @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null) : CoordinatorLayout(context, attrs), NestedScrollingChild3 { private val helper = NestedScrollingChildHelper(this) init { isNestedScrollingEnabled = true } override fun isNestedScrollingEnabled(): Boolean = helper.isNestedScrollingEnabled override fun setNestedScrollingEnabled(enabled: Boolean) { helper.isNestedScrollingEnabled = enabled } override fun hasNestedScrollingParent(type: Int): Boolean = helper.hasNestedScrollingParent(type) override fun hasNestedScrollingParent(): Boolean = helper.hasNestedScrollingParent() override fun onStartNestedScroll(child: View, target: View, axes: Int, type: Int): Boolean { val superResult = super.onStartNestedScroll(child, target, axes, type) return startNestedScroll(axes, type) || superResult } override fun onStartNestedScroll(child: View, target: View, axes: Int): Boolean { val superResult = super.onStartNestedScroll(child, target, axes) return startNestedScroll(axes) || superResult } override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int) { val superConsumed = intArrayOf(0, 0) super.onNestedPreScroll(target, dx, dy, superConsumed, type) val thisConsumed = intArrayOf(0, 0) dispatchNestedPreScroll(dx, dy, consumed, null, type) consumed[0] = superConsumed[0] + thisConsumed[0] consumed[1] = superConsumed[1] + thisConsumed[1] } override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray) { val superConsumed = intArrayOf(0, 0) super.onNestedPreScroll(target, dx, dy, superConsumed) val thisConsumed = intArrayOf(0, 0) dispatchNestedPreScroll(dx, dy, consumed, null) consumed[0] = superConsumed[0] + thisConsumed[0] consumed[1] = superConsumed[1] + thisConsumed[1] } override fun onNestedScroll( target: View, dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, type: Int, consumed: IntArray ) { dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null, type) super.onNestedScroll( target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type, consumed ) } override fun onNestedScroll( target: View, dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, type: Int ) { super.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, type) dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null, type) } override fun onNestedScroll( target: View, dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int ) { super.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed) dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null) } override fun onStopNestedScroll(target: View, type: Int) { super.onStopNestedScroll(target, type) stopNestedScroll(type) } override fun onStopNestedScroll(target: View) { super.onStopNestedScroll(target) stopNestedScroll() } override fun onNestedPreFling(target: View, velocityX: Float, velocityY: Float): Boolean { val superResult = super.onNestedPreFling(target, velocityX, velocityY) return dispatchNestedPreFling(velocityX, velocityY) || superResult } override fun onNestedFling( target: View, velocityX: Float, velocityY: Float, consumed: Boolean ): Boolean { val superResult = super.onNestedFling(target, velocityX, velocityY, consumed) return dispatchNestedFling(velocityX, velocityY, consumed) || superResult } override fun startNestedScroll(axes: Int, type: Int): Boolean = helper.startNestedScroll(axes, type) override fun startNestedScroll(axes: Int): Boolean = helper.startNestedScroll(axes) override fun stopNestedScroll(type: Int) { helper.stopNestedScroll(type) } override fun stopNestedScroll() { helper.stopNestedScroll() } override fun dispatchNestedScroll( dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, offsetInWindow: IntArray?, type: Int, consumed: IntArray ) { helper.dispatchNestedScroll( dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow, type, consumed ) } override fun dispatchNestedScroll( dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, offsetInWindow: IntArray?, type: Int ): Boolean = helper.dispatchNestedScroll( dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow, type ) override fun dispatchNestedScroll( dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, offsetInWindow: IntArray? ): Boolean = helper.dispatchNestedScroll( dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow ) override fun dispatchNestedPreScroll( dx: Int, dy: Int, consumed: IntArray?, offsetInWindow: IntArray?, type: Int ): Boolean = helper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type) override fun dispatchNestedPreScroll( dx: Int, dy: Int, consumed: IntArray?, offsetInWindow: IntArray? ): Boolean = helper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow) override fun dispatchNestedPreFling(velocityX: Float, velocityY: Float): Boolean = helper.dispatchNestedPreFling(velocityX, velocityY) override fun dispatchNestedFling( velocityX: Float, velocityY: Float, consumed: Boolean ): Boolean = helper.dispatchNestedFling(velocityX, velocityY, consumed)}" }, { "title": "Spring: Security 인가설정 - Basic", "url": "/posts/spring-security-basic/", "categories": "Dev, Spring", "tags": "spring, security", "date": "2022-02-02 00:00:00 +0900", "snippet": "SecurityConfigSpring-security 의존성 설정 후 WebSecurityConfigurerAdapter을 상속하여 기본적인 인증, 인가 처리에대한 설정을 할 수 있다.Authorization configconfigure(HttpSecurity) 함수를 오버라이드하여 설정한다.여러 메소드를 chaining하는 방법으로 설정이 진행되며chaining 순서 그대로 인가 정책의 우선순위가 결정되므로좁은범위 → 넓은범위 순으로 정책을 작성해야된다.override fun configure(http: HttpSecurity) { http .authorizeHttpRequests() .antMatchers(&quot;/shop/pay&quot;).hasRole(&quot;USER&quot;) // 1 .antMatchers(&quot;/shop/**&quot;).hasAnyRole(&quot;GUEST&quot;, &quot;USER&quot;) // 2 .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) .anyRequest() .authenticated() .and() .formLogin()}shop/pay 경로에는 UESR 권한이 요구되며 그 외 shop 하위경로는 GUEST, USER 모두 접근가능한 설정에 대한 예시이다. 이 때 1,2 의 순서가 변경되면 shop의 모든 하위경로 /shop/** 에 GUEST, USER 모두 접근가능한 정책이 선 반영되어 /shop/pay 의 USER 권한이 요구되는 정책은 무시된다.inMemoryAuthentication테스트를위한 Authentication 정보 설정override fun configure(auth: AuthenticationManagerBuilder) { with(auth) { inMemoryAuthentication().withUser(&quot;user&quot;).password(&quot;{noop}1234&quot;).roles(&quot;USER&quot;) inMemoryAuthentication().withUser(&quot;guest&quot;).password(&quot;{noop}1234&quot;).roles(&quot;GUEST&quot;) inMemoryAuthentication().withUser(&quot;admin&quot;).password(&quot;{noop}1234&quot;).roles(&quot;ADMIN&quot;) }}password의 {} 구문은 password encoding에 대한 내용이며 noop은 따로 적용된 encoding이 없다는 표시이다." }, { "title": "KMM: Ktor client 설정", "url": "/posts/kmm-ktor-client/", "categories": "Dev, KMM", "tags": "kmm, ktor", "date": "2022-01-28 00:00:00 +0900", "snippet": "Ktor-clientHttp-client 라이브러리, kotlin &amp;amp; coroutine를 기반으로 구축되었으며 가볍고 강력한 비동기 통신을 지원한다.본 글에서는 ktor-client 설정에 대하여 정리 2.0.0-beta 기준SetupHttpClient는 정의는 크게 아래 3가지 조합으로 이뤄진다.HttpClientPluginConfig와 Plugin이 분리되어있으며 install(PLUGIN, CONFIG initalizer) 를 통해 HttpClient에 적용 할 수 있다.Plugin에서 install 및 prepare 함수를 구현하여 설정값(CONFIG)에 따라 interceptor등을 추가하여 원하는 동작을 구현한다.HttpEngineHttpEngine은 interface이며 각 플랫폼별 HttpEngine provider를 정의하여 사용하면 된다.대표적으로 CIO, OkHttp, IOS 등이 있다.Example in koinsingle { OkHttp.create() // HttpEngine}single { HttpClient(get()) { install(ContentNegotiation) { json() } install(Logging) { logger = object : Logger { override fun log(message: String) { localLogger.log(message) } } level = LogLevel.ALL } install(HttpTimeout) { val timeout = 30000L connectTimeoutMillis = timeout requestTimeoutMillis = timeout socketTimeoutMillis = timeout } }}ReferenceKtor: Build Asynchronous Servers and Clients in Kotlin" }, { "title": "Spring: JPA 테스트(더미) 데이터 설정", "url": "/posts/spring-db-init/", "categories": "Dev, Spring", "tags": "spring, jpa", "date": "2022-01-25 00:00:00 +0900", "snippet": "들어가며이번 글에서는 테스트용 데이터 초기화를 위한 방법 중 spring, hibernate에서 자동으로 인식하는 sql file(import, schema, data)를 통한 초기화 방법과 EventListener를 활용하여 코드를 통한 초기화 방법에대해 정리한다.import.sqlHibernate를 통해 scheme생성을 진행하는 경우 (create, create-drop property 사용) import.sql 파일이 존재하면 초기화를 진행한다.schema.sql, data.sqlSpring boot 실행시 scheme.sql, data.sql 파일이 존재하면 실행한다. (hibernate 초기화 이전) 즉, 테스트용 profile이 존재하고 hibernate를 통해 DB scheme를 생성하는 프로젝트에서는 data.sql을 사용하면 scheme가 생성되지않은 상태라 Exception이 발생한다.EventListenerSpring component를 구현하고 원하는 Event class의 EventListener annotation을 등록해두면 해당 이벤트에 대한 리스너 등록이 가능하다.Spring에서 제공하는 여러 ApplicationEvent가 있지만 이번글에서는 ApplicationReadyEvent 가 발생하는 시점에 테스트용 데이터 초기화를 진행한다.@Profile(...)@Component@RequiredArgsConstructorpublic class EntityInitializer { private final MyRepository myRepository; @EventListener public void init(ApplicationReadyEvent event) { myRepository.saveAll( List.of(...) ); }}정해진 profile(for test)에서만 동작하도록 Profile annotation도 함께 추가" }, { "title": "Spring: AES 암호화 복호화", "url": "/posts/spring-aes/", "categories": "Dev, Spring", "tags": "spring, security", "date": "2022-01-25 00:00:00 +0900", "snippet": "AES(Advanced Encryption Standard)?대표적인 양방향(대칭) 암호화 알고리즘중 하나이며 AES-{bitLength} 포멧의 이름을 가진다. 즉, AES-256은 256bit 길이를 가지는 암호화 키(Secret key)가 사용된다.예제서버 config값 기반으로 암/복호화에 사용하는 Component 정의@Componentpublic class AESUtil { private byte[] key; private SecretKeySpec secretKeySpec; @Autowired public AESUtil(@Value(&quot;${your secretkey path}&quot;) String rawKey) { try { MessageDigest sha = MessageDigest.getInstance(&quot;SHA-1&quot;); key = rawKey.getBytes(StandardCharsets.UTF_8); key = sha.digest(key); key = Arrays.copyOf(key, 24); secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;); } catch (Exception e) { log.error(e.getMessage()); } } public String encrypt(String str) { try { //알고리즘/블럭 암호화 방식/Padding방식(메세지 길이가 짧은 경우 어떻게 처리 할 것인가?) Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); //cipher를 통한 암호화 결과 타입은 byte array이다. 이를 쉽게 다루기위해 base64 string 으로 encoding하여 사용한다. return encodeBase64(cipher.doFinal(str.getBytes(StandardCharsets.UTF_8))); } catch (Exception e) { log.error(&quot;Error while encrypt: &quot; + e); return null; } } public String decrypt(String str) { try { Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKeySpec); return new String(cipher.doFinal(decodeBase64(str))); } catch (Exception e) { log.error(&quot;Error while decrypt: &quot; + e); return null; } } private String encodeBase64(byte[] source) { return Base64.getEncoder().encodeToString(source); } private byte[] decodeBase64(String encodedString) { return Base64.getDecoder().decode(encodedString); }}" }, { "title": "KMM 조사: 2장, 뭣이 다른디? 차이점", "url": "/posts/kmm-intro/", "categories": "Dev, KMM", "tags": "kmm", "date": "2022-01-23 00:00:00 +0900", "snippet": "기존 크로스 플랫폼과 무엇이 다른가?Flutterdart로 작성된 프로젝트를 flutter compiler를 통해 native app이 만들어진다. 각 플랫폼별 별도의 방법으로 rendering 구현이되어있으며 어플리케이션을 제작하는데 필요한 다양한 라이브러리들이 존재한다.React Native리엑트 네이티브는 리엑트 진영에서 만든 AOS, IOS용 크로스 플랫폼 프레임 워크이다.JavaScriptCore엔진을 통해 실행되며 부분적이지만 플랫폼별 네이티브 기능을 제공한다. 이를 런타임에서 Bridge를 통해 네이티브기능을 실행하는 방식이다.Ionic웹 베이스로 작성된 프로젝트를 assets을 포함하여 감싼형태로 플랫폼별 런타임을 만들어주는 방식. 웹뷰베이스로 실행된다.Native Project?위 그림을보면 프로젝트 작업 방식(언어)와 결과물에대한 개략적인 내용을 나타낸다. 기존의 크로스플랫폼 프레임워크의 결과물은 모두 플랫폼별 런타임(apk, ipa, …)인 반면 KMM은 각 플랫폼별 Project 파일인것을 알 수 있다.이 부분이 본글을 관통하는 핵심 내용이며 KMM의 가장 강력한 장점중 하나라고 생각한다.기존 크로스플랫폼의 프레임워크의 가장 큰 문제가 웹뷰 또는 프레임워크 내부 구현체(코어, 엔진)로 동작하는 런타임이 생성되기때문에 플랫폼에서 제공하는 최적화나 각종 네이티브 UI컴포넌트의 이점을 제대로 누리지 못하는 경우가 많다. 이 때문에 네이티브의 7~80%정도의 퀄리티까지는 가능하나 그 이상은 힘들고 복잡한 UI를 구성할수록 퍼포먼스 이슈도 발생한다.요약기존 프레임워크는 플랫폼별 런타임이 결과물이다. 반면 KMM은 각 플랫폼별 프로젝트가 결과물이다.이게 왜 장점인지에 대한 내용들은 별도로 정리해보자." }, { "title": "Flutter: Widget &amp; Element", "url": "/posts/flutter-intro/", "categories": "Dev, Flutter", "tags": "flutter", "date": "2022-01-23 00:00:00 +0900", "snippet": "Flutter? Flutter transforms the app development process. Build, test, and deploy beautiful mobile, web, desktop, and embedded apps from a single codebase.dart로 작성한 하나의 프로젝트를 flutter cross-compiler를 활용하여 멀티 플랫폼 런타임을 생성해주는 프레임워크.아직까진 점유율이나 생태계측면에서 성장하고있는 단계인것으로 보여지며 작성된 flutter widget들을 프레임워크별로 최적화된 rendering과정을 통해 나타내는 방식이라 성능도 우수한편이다.본 글에서는 이러한 일련의 과정들을 알아보고 정리해보고자 한다.Widget? Describes the configuration for an Element.Flutter framework의 핵심 클래스.Widget은 유저 인터페이스의 일부에 불변 설명이다. (무슨말이야..?)풀어서 설명하자면 일반적인 Widget의 경우 모두 불변상태이며 이를 활용해 Element inflating을 진행한다.가변상태의 Widget이 필요의 경우 StatefuleWidget을 사용한다.Element와 연결된다Flutter Render(Element) tree를 만드는 과정에서 모든 Widget은 Element로 연결되며 하나의 트리를 생성하는 과정에서 하나의 위젯이 여러곳에 위치 할 수 있다.요약 Widget은 UI의 구현체이고 불변 상태를 가진다. 즉, 이를 통해 Render tree를 구성할 때 중복 객체(Element) 생성을 막는 등 다양한 내부 메커니즘을 구현하는데 사용된다.Element? An instantiation of a Widget at a particular location in the tree.Widget은 UI의 구성중 일부를 나타낸다. 즉, 일반적으로 한 화면은 여러 Widget의 계층형 집합이며 하나의 부모 위젯에 여러 자식위젯이 존재하는 등의 구현이 가능하다.따라서, 한 화면에는 여러개의 동일한 위젯이 존재 할 수 있으며 이들은 구현에따라 state만 다르거나(StatefulWidget) state 또한 동일한 Widget 일 수 있다.매우 높은 실시간성을 요구하는 현재의 프론트엔드환경에서 이러한 화면의 구성들은 언제든지 빠르게 업데이트 되는 경우가 많다. 따라서, 보다 탄력적으로 대응하기위해 실제 UI 구현체인 Widget은 재사용하고 Element를 통해 각 Widget의 location 정보를 갱신한다.Element lifecycle Widget.createElement를 통해 초기화를 진행 생성된 Element는 마운트 과정을 통해 지정된 위치의 트리에 추가 해당 시점에서 마운트된 위치에따라 화면에 노출 될 수 있다(active) UI가 업데이트 되는 시점에 비활성화 조건에 성립되면 Element는 비활성화 처리된다. 주로 부모 Element에서 deactivateChild를 통해 비활성화 된다. 해당 Element가 다시 활성화 되면 Owner의 deactive element 목록에서 이를 제거하고 다시 재사용한다. …추상적인 설명이고 디테일한 부분은 많이 찾아봐야될듯하다.결론 Element는 Widget과 RenderObject를 연결한다. Widget은 Element로 변환되며 Element는 계층적으로 위젯의 구조와 구현에 따라 적절한 Render Tree를 생성한다. 즉, Widget tree와 Element tree 구조는 동일하나 Render tree의 경우 동일하지 않게 생성되는점을 이해하자. (ex, Element가 초기화 될 때 active상태로 화면에 노출되고 불변 element(stateless)면 Render tree에 포함되지 않는다.)ReferenceWidget class - widgets library - Dart APIElement class - widgets library - Dart API" }, { "title": "KMM 조사: 1장 오프닝, 소개", "url": "/posts/kmm-index/", "categories": "Dev, KMM", "tags": "kmm", "date": "2022-01-22 00:00:00 +0900", "snippet": "Kotlin multiplatform mobile Write once the business logic for different platform.jetbrain과 google이 참여하고있는 kotlin foundation의 프로젝트중 하나, 코틀린이라는 언어가 궁극적으로 지향하는 platform independent language를 가장 잘 나타내주는 프레임워크이며, 개인적으로 기존 크로스 플랫폼 프레임워크의 단점, 한계점을 개선해줄 수있는 가장 강력한 멀티플랫폼(+with kotlin)이지 않을까 생각이 들었고 든든한 미래먹거리를 준비하기위해 천천히 한번 정리해보는 시간을 가지려고 한다.목차 차이점 TODO결론 TODO" }, { "title": "Ioc, DI, DIP: 그놈이 그놈이아니다.", "url": "/posts/ioc-di-dip/", "categories": "Dev, Log", "tags": "design pattern, IoC, DI", "date": "2022-01-20 00:00:00 +0900", "snippet": "IoC (Inversion of Control) Ioc is a common phenomenon Ioc는 일반적인 디자인 원칙중 하나이다. 작성한 코드의 제어가 역전된 상황에 모두 적용할 수 있다. 흔히 사용되는 이벤트루프 또는 콜백 및 트리거 함수들이 이에 포함된다.CLI programPRINT &quot;이름?&quot;READ namePRINT &quot;나이?&quot;READ ageSTORE name, agecli 기반의 유저의 이름과 나이를 입력받아 저장하는 프로그램의 의사코드이며 이를 구현한 프로그램은 작성된 흐름으로 제어(진행)된다.GUI(Android) programeditTextName.hint = &quot;이름?&quot;editTextAge.hint = &quot;나이?&quot;btnStore.setOnClickListener { val name = editTextName.text.toString() val age = editTextAge.text.toString() store(name, age)}여기서, 해당 프로그램은 내가 작성된 흐름으로 제어되지않고 user interaction을 토대로 android framework에서 제어한다. 즉 프레임워크에의한 제어 역전이 발생한 예시이다.위 예제 뿐만아니라 Callback, Handler, EventLoop등 다양한 곳에 적용된 디자인 원칙일 뿐이라고 이해하면 된다.결론 Ioc ≠ DI ≠ DIP 왜 위 3개념이 혼용되는지에 대해 추측해본다면, 우리가 많이 사용하는 DI 프레임워크들이 Ioc 디자인 원칙을 따라 구현되어있으며 이를 토대로 DIP를 구현하다보니 오해가 생긴게 아닐까? 하는 생각이 든다.참고What is Inversion of Control?" }, { "title": "Spring: ControllerAdvice, ExceptionHandler를 활용한 예외처리", "url": "/posts/spring-exception-handling/", "categories": "Dev, Spring", "tags": "spring, exception", "date": "2022-01-19 00:00:00 +0900", "snippet": "Spring error handling 기본따로 예외처리를 구현하지 않았을 때, Spring servlet 내부에서 발생한 예외가 servlet container까지 전파되며 servlet container에서는 BasicErrorController 를 통해 예외처리를 진행한다.application config값에 따라 노출하는 내용, 에러 페이지등을 다르게 설정 가능하다.@ControllerAdviceSpring component annotation이며 기본적으로 global-scope에서 발생하는 exception에 대한 예외처리를 제공해주며. basePackage 인자를통해 scope를 별도로 지정 할 수 있다.@ControllerAdvice(basePackages = ...)Spring-mvc에서는 ResponseEntityExceptionHandler를 상속하여 함수 오버라이딩을 통해 보다 편리하게 전역적인 ControllerAdvice를 작성 할 수 있다.@ControllerAdvicepublic class GlobalErrorHandler extends ResponseEntityExceptionHandler { @Override protected ResponseEntity&amp;lt;Object&amp;gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { ... } @Override protected ResponseEntity&amp;lt;Object&amp;gt; handleTypeMismatch(TypeMismatchException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { ... }}@ExceptionHandlerComponent 단위로 함수의 ExceptionHandler annotation확인하여 해당 Component 영역에서의 예외처리기능을 제공ControllerAdvice - servlet scope@ControllerAdvicepublic class GlobalErrorHandler { @ExceptionHandler(ContraintViolationException.class) public void handleConstraintViolationException(ConstraintViolationException e, ServletWebRequest webRequest) { ... }}Controller - controller scope@RestControllerpublic class LoginController { ... @ExceptionHandler(LoginException.class) public void handleException(LoginException e, ...) { ... }}결론전역적으로 사용하는 Exception의 경우 ControllerAdvice를 통해 처리하고Controller scope에서 발생하는 ControllerScopedCustomException의 경우 Controller 내부에서 ExceptionHandler를 활용하여 처리한다." }, { "title": "Spring: jackson InvalidDefinitionException", "url": "/posts/spring-exception-InvalidDefinition/", "categories": "Dev, Spring", "tags": "spring, jackson, trouble", "date": "2022-01-18 00:00:00 +0900", "snippet": "문제점intellij에서 built-in gradle을 사용하고 lombok + jackson을 활용할때 발생하는 이슈원인위 환경에서 일반 gradle build를 사용하는경우 자동으로 컴파일러 옵션을 활성화 시켜주는데(-parameters) built-in gradle을 사용 할 때는 해당 옵션이 활성화 되지않는다. 따라서, jackson이 deserialize를 실패하여 exception 발생해결책-parameters 컴파일 옵션 추가" }, { "title": "Spring: FilterProxy, FilterChain 기본", "url": "/posts/spring-filter-chain/", "categories": "Dev, Spring", "tags": "spring, security", "date": "2022-01-16 00:00:00 +0900", "snippet": "들어가며FilterProxy에 대한 개략적인 정리FilterProxy?수신된 Request에 대해 config(matcher, …)를 토대로 적합한 FilterChain을 생성해준다. request, response시 하나의 filterChain을 통과하며 filter chaining이 발생한다. 따라서, filter의 구현에서 servlet의 내용을 수정하는 경우 이후 filter에서도 수정된 내용이 그대로 적용되는 것을 명심해야된다.Filter Chaining위의 이해를 돕기위해 A,B,C의 필터 구현이 아래와 같을경우fun doFilter(request:~, response:~, chain: FilterChain) { log(&quot;before : $filterName&quot;) chain.doFilter(request, response) log(&quot;after : $filterName&quot;)}아래와 같이 log가 출력된다.before : Abefore : Bbefore : C~~~after : Cafter : Bafter : ADefaultSecurityFiltersWebAsyncManagerIntegrationFilterSecurityContextPersistenceFilterHeaderWriterFilterCsrfFilterLogoutFilterUsernamePasswordAuthenticationFilterDefaultLoginPageGeneratingFilterDefaultLogoutPageGeneratingFilterBasicAuthenticationFilterRequestCacheAwareFilterSecurityContextHolderAwareRequestFilterAnonymousAuthenticationFilterSessionManagementFilterExceptionTranslationFilterFilterSecurityInterceptorSecurity 활성화시 기본적으로 생성되는 Filter이며 Security Config에 따라 Filter의 동작과 FilterChain에 포함되는 Filter 종류가 달라진다." }, { "title": "Spring: 이메일 전송 구현 via smtp", "url": "/posts/spring-emailsender/", "categories": "Dev, Spring", "tags": "spring, email", "date": "2022-01-15 00:00:00 +0900", "snippet": "들어가며smtp protocol을 활용하여 spring project에서 메일을 전달하는 기본 방법에 대해 정리.smtp 서버를 직접 구축하거나 smtp를 지원하는 메일 서비스를 통해 구현 가능하다.JavaMailSender?springframework.mail의 MailSender를 구현한 클래스이다.MailMessage interface를 구현한 MimeMessage 클래스를 인자로 받아 메일을 전송한다.application config가 적용된 구현체를 bean을 통해 주입 받을 수 있다.의존성 추가implementation &#39;org.springframework.boot:spring-boot-starter-mail&#39;설정mail: host: smtp.gmail.com # your smtp host port: 587 username: &#39;{smtp-username}&#39; password: &#39;{smtp-password}&#39; properties: mail: smtp: auth: true starttls: enable: true메일 전송@RequiredArgsConstructor@RestControllerpublic class FooController { private final JavaMailSender mailSender; public void sendEmailExample() { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(&quot;from-email&quot;); message.setTo(&quot;to-email&quot;); message.setSubject(&quot;제목&quot;); message.setText(&quot;내용&quot;); mailSender.send(message); }}참고 Sending Email with Spring mail" } ]
